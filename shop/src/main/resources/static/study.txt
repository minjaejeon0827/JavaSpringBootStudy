[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
1강 - Spring Boot 왜 쓰는데
2강 - 개발환경 셋팅 / Spring Boot 3 프로젝트 생성

* intellij community 에디터 설치 방법
참고 URL - https://blog.naver.com/PostView.naver?blogId=djusti&logNo=223143383341
참고 2 URL - https://priming.tistory.com/50

* spring initializr 이용하여 프로젝트 생성
참고 URL - https://start.spring.io/
참고 2 URL - https://guns23.tistory.com/8
참고 3 URL - https://nohriter.tistory.com/115

* spring boot 공식 문서
참고 URL - https://docs.spring.io/spring-boot/documentation.html

3강 - 자바 기본 문법 1 (변수, 함수, if, for)
4강 - 자바 기본 문법 2 (class, constructor)





[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
3강 - 자바 기본 문법 1 (변수, 함수, if, for)

변수, 함수, if, for 이런 기초 개념은 알고있다고 가정하고 진행할 것이다.
꼭 자바로 변수, 함수 이런걸 배울 필요없고 자바스크립트 같은 다른 언어로 배워와도 전혀 상관없다.
어짜피 다 똑같음
그래서 자바에서 변수, 함수, if, for 어떻게 쓰는지 빠르게 정리하고 가보자.

* 코드 어디에 적냐면

public static void main(String[] args) {
  SpringApplication.run(ShopApplication.class, args);
  코드~~
}

코드를 어디다가 적어야하냐면 어쩌구Application.java 파일(예 - ShopApplication.java)이 있을텐데
거기에 있는 main 함수안에 적으면 실행된다.
자바프로젝트 실행하면 main 함수안의 코드가 자동으로 실행이 되어서 그렇다.

* 변수 문법

자바에서도 당연히 변수를 만들어 쓸 수 있다.
어떤 자료를 잠깐 저장해두고 쓰고싶을 때 변수를 사용한다.

타입 변수명 = 변수에넣을값;
이렇게 코드짜면 변수생성 끝이다.

String name = "kim";
int age = 20;
float num = 1.5;

- 문자는 항상 큰 따옴표("") 안에 넣는다.
- 한 줄 끝나면 세미콜론(;)을 붙여야한다.
- 타입은 변수에 들어갈 자료의 타입(String, int, float 등등...)을 기재하면 된다.

저장할자료         | 타입이름
문자              | String
정수              | int
큰 정수(20억 이상)  | long
소수              | float
오차가 더 적은 소수  | double
true/false        | boolean

기본 타입은 이런 것들이 있다.

String lover = "김말자";
System.out.println(lover);

님들 여친 이름을 변수(lover)에 저장해서 출력해보자.
없으면 이번 기회에 자바로 만들자.
변수나 자료를 출력하고 싶으면 System.out.println() 안에 넣으면 된다.
IntelliJ 에디터에선 sout 라고 쓰고 엔터치면 System.out.println() 자동완성된다.

@SpringBootApplication
public class ShopApplication {

	public static void main(String[] args) {

		SpringApplication.run(ShopApplication.class, args);   // Spring boot로 만든 웹서버 띄우기
	}

}

코드 실행하려면 class 옆에 있는 재생버튼(▷) 누르면 된다.
참고로 한번 누르면 이제 에디터 상단에 있는 재생버튼(▷) 눌러도 된다.
재생버튼(▷) 생긴게 마음에 안들면 Debug 버튼(벌레 모양) 눌러도 된다.

코드 내용을 수정했으면 다시 정지(□)하고 재생(▷)눌러도 되는데
그게 싫으면 실시간으로 다시 컴파일해주는 기능도 있다.

ctrl + F9 누르면 된다.
맥은 command + F9임

* var 키워드

타입적는게 귀찮거나 무슨 타입 적어야할지 모르겠으면 var 이런 키워드를 사용해도 된다.
(Java 10버전 이상부터 사용가능)

var name = "kim";
var age = 20;

타입 자리에 var 적으면 얘가 알아서 타입을 유추해서 적용해준다.
편리하죠?

그래서 var 가끔쓰면 깔끔해보일 수 있어서 쓸지말지는 알아서 판단하면 되는데
실은 그런 코드스타일 같은건 같이 일하는 팀원들이랑 맞추는게 좋다.
참고로 자바 대용품으로 요즘은 Kotlin 언어를 많이 도입하는데 거기선 타입유추기능 쓰는 사람들이 많이 보이는거 같다.

* final 키워드 (상수)
가끔 final을 왼쪽에 붙여서 만들기도 하는데 이러면 변수에 들어있는 값을 나중에 바꿀 수 없다.

final int wifeCount = 0;
wifeCount = 20; //에러남

변수에 들어있는 값을 바꾸려고 하면 에러로 잡아준다.
그래서 바뀌면 큰일나는 값들을 저장할 때 주로 쓰도록 하자.
예를 들어 여러분의 여친숫자, 불알갯수 저장할 땐 final 붙이는게 어떨까요.

* if 조건문

if (조건) {
  조건이 참일 때 실행할 코드~~
}

특정 조건이 맞을 때만 코드를 실행하고 싶으면 if 조건문 안에 넣으면 된다.

int wifeCount = 0;

if (wifeCount == 0) {
  System.out.println("정상");
}

예를 들어 여러분의 여친 수량이 0일 때만 특정 코드를 실행하고 싶은 경우 위처럼 작성하면 된다.
조건자리에는 ==, !=, >, < 같은걸 사용하는 조건식을 주로 입력한다.

* for 반복문

비슷한 코드를 여러번 복붙하고 싶으면 for 꺼내서 쓰면 된다.

for (int i = 0; i < 3; i++) {
  복붙할 코드~~
}

위 코드는
(1) i를 0부터 시작해서
(2) i가 3이 되기 전까지
(3) i에 +1하면서 계속 복붙하라는 소리기 때문에
3번 복붙이 되겠군요. 이거 모르면 자바스크립트 기초강의 들을 시간임

* 함수

긴 코드 덩어리를 자주 재사용하고 싶을 때 함수를 만들어쓰기도 한다.
자바에서도 함수를 만들어서 쓸 수 있는데

public class ShopApplication {

  void 함수(){
    System.out.println("안녕");
  }

  public static void main(String[] args) {
    SpringApplication.run(ShopApplication.class, args);
  }
}

함수 만들고 싶으면 보통 class 안에 만들어서 가져다쓰면 된다.
함수이름(){} 이렇게 함수를 정의해둘 수 있고
함수정의 왼쪽에 return 타입을 넣으면 된다.
그니까 함수 안에 return이 있을 경우 return 하고 있는 자료가 무슨 타입인지 미리 적어놔야한다.
return이 없으면 void 라고 적으면 된다.

하지만 함수를 가져다가 쓰려면 new 키워드로 object를 뽑아서 쓰는게 일반적이라
그건 다음 시간에 class 배우면 알아보도록 하자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
4강 - 자바 기본 문법 2 (class, constructor)

* class가 뭐냐면

자바로 코드짤 때 class를 많이 보게 될텐데 class에 대해 알아보자.
이거 설명할 때 붕어빵 틀이니 상속이니 뭐니 하면서 어렵게 설명하는 사람들이 있는데
그딴거 필요없고 class가 뭐냐면 그냥 변수와 함수 보관하는 통이다.

class Test {
  String name = "kim";
  void hello() { System.out.println("안녕"); }
}

class 만들려면 class 작명 { } 하면 된다.
- 중괄호 안에 변수나 함수를 맘대로 여러개 보관해둘 수 있다.
- 참고로 System.out.println 쓰기 귀찮으면 sout라고 쓰고 엔터누르면 자동완성된다.
- 보관했던 변수와 함수를 자유롭게 가져다쓸 수도 있다.

* class에 있던 변수 함수 사용하려면

class에 보관해뒀던 변수랑 함수를 쓰고 싶으면 class의 복사본부터 만들어야한다.

var test = new Test();

new 클래스() 라고 쓰면 클래스에 있던 변수랑 함수 복사해주세요~ 라는 뜻이다.
그러면 진짜로 클래스에 있던 변수랑 함수를 복사해온 이상한 자료가 그 자리에 남는다.
참고로 변수랑 함수 복사본 담고있는 이상한 자료를 멋있게 object라고 부른다.

var test = new Test();
System.out.println(test.name);

object 안에 저장된 변수랑 함수를 가져다쓰고 싶으면
점찍어서 변수나 함수 꺼내서 쓰면 된다.
그래서 .name 붙이면 이 자리에 아까 Test 클래스에 보관해놨던 kim이라는 변수가 남는 것임
test.hello() 처럼 그 안에 있던 함수도 사용할 수 있다.
진짜 되나 main 함수 안에서 실행해보십쇼

Test test = new Test();

클래스를 복사해올 때 타입을 정확히 넣고 싶으면 뭘넣어야하냐면
타입자리에 클래스명 넣으면 된다.
클래스도 일종의 자료형 역할을 할 수 있어서 그런 것임

정리를 하자면
1. 클래스 쓰면 변수랑 함수들을 보관해둘 수 있음
2. 보관해둔 변수나 함수 쓰려면 new 클래스(); 로 클래스 복사본을 하나 만들어서 점찍어서 꺼내써야함
3. new 키워드로 뽑은 클래스 복사본을 object라고 멋있게 부름

* class 쓰는 이유

근데 여러분들 문법 배우는게 중요한게 아니라
이걸 왜 쓰는지 배워야 나중에 활용을 할 수 있다.

그냥 변수 아무데나 만들어서 쓰면 되는데
왜 귀찮게 클래스 따로 만들어서 변수함수를 보관해두고 복사해서 가져다가 쓰냐고요?
이유는 3개 정도 있다.


1. 자바를 선택한 이상 자바에선 항상 코딩을 클래스부터 써놓고 시작하기 때문에 어쩔 수 없이 강제로 써야함

2. 관련있는 변수, 함수를 한 곳에 보관할 수 있으니까 코드 정리해두기 좋음

3. 중요한 변수, 함수 원본을 안전하게 보관할 수 있음
- 님들 중요한 서류 수정할 때 원본을 직접 수정합니까
원본을 직접 수정하고 그러면 좀 위험할 수 있어서 보통은 복사한 다음에 그걸 가져다가 쓰는게 안전하다.
class도 마찬가지로 변수, 함수 원본을 보관해두고
이걸 new 키워드로 복사해서 쓰면 원본 데이터를 안전하게 그대로 지킬 수 있으니까 그래서 쓰는 것이다.

그래서 이런 장점들 때문에 class를 쓰는 개짓거리를 하는데
실은 장점들이 몇개 더 있다. 그건 나중에 코드짤 때 체감해보자.

(참고1)
클래스안에는 복사안되는 변수도 만들 수 있고
복사안해도 쓸 수 있는 변수도 만들 수 있고
그럴 수도 있다.
static private 같은 여러 키워드들 쓰면 되는건데 나중에 알아보자.

(참고2)
object를 다른 말로 인스턴스라고 부르기도한다.
클래스 안에 있는 변수는 field / attribute 라고 부르기도 하고
클래스 안에 있는 함수는 method라고 부르기도 한다.
있어보이는 척 할 때 써보도록 하자.

* constructor 문법

이번엔 constructor 문법을 배워볼건데 그냥 배우면 재미가 없으니까 상황을 한번 가정해보자.
다들 친구 한 명은 있을텐데 친구없으면 이번 기회에 가짜로 하나 만드시고요

Q. 내 친구 한 명의 이름과 나이를 변수로 저장해놓고 싶으면 어떻게 하죠?
친구의 이름, 나이 저장할 변수 2개를 만들면 될 것 같은데
클래스 배운 사람들이니까 클래스 하나 만들어서 거기 안에 넣어보도록 하자.

class Friend {
  String name = "kim";
  int age = 20;
}

Friend라고 클래스 하나 만들어서 이름, 나이를 보관해봤다.
그럼 앞으로 이 친구의 나이가 필요하면 어떻게 합니까
new Friend()로 object 뽑아서 쓰면 되겠네요. 심심하면 뽑아서 출력해보자.

Q. 근데 이번엔 친구가 한 명 더 생겼습니다.
그 친구는 나이는 똑같은데 이름이 "park"이다.
그 친구도 클래스 하나 만들어서 이름, 나이 저장해두고 싶으면 어떻게 하죠?

class Friend1 {
  String name = "park";
  int age = 20;
}

클래스 하나 더 만들어서 이러면 된다.

Q. 근데 이번에 또 다른 이름의 친구가 또 생기면 어쩔 것임?
- 실은 비슷한 클래스는 굳이 여러개 만들 필요가 없다.
클래스에서 쓸 수 있는 constructor와 파라미터문법을 쓰면
object 뽑을 때 마다 매번 다른 변수값을 가지도록 클래스를 만들 수 있다.

class Friend {
  String name = "kim";
  int age = 20;
  Friend() {
    this.name = "어쩌구";
  }
}

여기 class 안에다가 클래스랑 똑같은 이름의 함수( ){ }를 하나 만들어보자.
그러면 이건 슈퍼 울트라 스페셜한 함수가 되는데
이 함수는 object를 하나 만들 때 자동으로 실행된다.

이 스페셜함수안에는 신기한 this라는 키워드도 쓸 수 있다.
this는 새로 생성될 object를 뜻한다.
this.name = “어쩌구”
그래서 this를 활용하면 이런 식으로 name 변수의 초깃값을 맘대로 설정해줄 수도 있다.
위 코드는 그래서 새로 생성될 object의 name 변수에 "어쩌구" 넣으라는 소리이다.

Q. 뭔가 문법을 배웠으면 이걸 왜 쓰는지 생각해봐야 나중에 활용이 가능하다. 이거 왜 쓰는 것임?
- 이거 스페셜한 함수랑 this문법을 잘 쓰면
object를 뽑을 때 마다 매번 다른 값을 변수에 집어넣어서 뽑을 수도 있다.
그니까 뽑을 때 마다 name변수에 "kim"도 넣고 "park"도 자유롭게 넣어서 뽑을 수 있음

class Friend {
  String name = "kim";
  int age = 20;
  Friend(String 이름){
    this.name = 이름;
  }
}

어떻게 하냐면 매번 가변적으로 설정할 부분에다가 파라미터를 추가해보면 된다.
저는 이름이라는 파라미터를 뚫어봤다.
파라미터도 일종의 변수라서 왼쪽에 타입도 집어넣어야함

var friend1 = new Friend("kim");
var friend2 = new Friend("park");

이런 짓을 해두면 이제 new Friend() 으로 object 뽑을 때
이 때 소괄호 안에 원하는 값("kim", "park")을 집어넣어서 뽑을 수 있다.
예를 들어서 “park” 이렇게 집어넣어볼 수 있는것이다.
그럼 파라미터자리에 뿅 박혀서 뽑힙니다.

Q. 그래서 위에 있는 변수 2개에 있던 name을 출력해봅시다. 뭐나오게요
System.out.println(friend1.name);
System.out.println(friend2.name);

Q. 그럼 name이 "lee"인 친구를 한명 만들고 싶으면 어떻게 코드짜야합니까
var friend3 = new Friend("lee");
System.out.println(friend3.name);

(참고1)
this는 생략해도 된다.
this없어도 그냥 this 생략되었겠거니 하면서 컴퓨터가 알아서 채워주고요

(참고2)
파라미터는 원하는 만큼 많이 만들 수 있다.

(참고3)
슈퍼 울트라 스페셜 함수를 개발자 말로 constructor라고 부른다.

* 객체지향 프로그래밍

class와 object를 많이 활용해서 개짓거리 하는걸 객체지향 프로그래밍이라고 부르기도 하는데
그래서 자바로 코드짠다고해서 객체지향에 대해서 많은걸 배워오려고 하는 분들이 있는데
객체지향 문법은 길고 복잡한 코드 정리도구, 관리도구일 뿐이다.
초보 때는 관리할 코드도 없는데 관리법부터 배우면서 시간낭비할 필요가 없다.

(1) class 만들고
(2) object 뽑는거
(3) constructor 쓰는거
이 정도만 알고 있으면 개발하는데 전혀 문제없다.
스프링 부트는 특히나 코드 창조할 일 보다 코드 배치하는 일이 더 많아서 이런거 몰라도 코드짤 수 있는 정도이다.

* 배운거 정리

1. 클래스는 변수 함수 보관함임

2. 클래스에 있던 변수함수를 사용하고 싶으면 new 클래스()로 object를 뽑으면 된다.
그럼 클래스 안에 들어있던 변수 함수가 object로 복사된다.

3. object 뽑을 때마다 각각 다른 변수값을 부여하고 싶으면 constructor를 만들면 된다.
클래스이름( ){ } 으로 함수만들면 그게 constructor임
그 안에 있는 코드는 object 뽑을 때 자동실행되므로 this 같은거 써서 변수의 초깃값을 맘대로 설정할 수도 있다.
심지어 함수 파라미터 문법도 사용가능

4. field, attribute, method, instance라는 용어 배움

1~2번은 자주 사용할 것이기 때문에 죽고싶지 않으면 이 정도는 외워두자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
5강 - 웹서버와 웹페이지 만들기 (Controller)

* 서버가 뭐냐면

서버가 뭐냐면 그냥 유저가 데이터 요청하면 그 데이터 보내주는 따까리 같은 프로그램일 뿐이다.
이거 해줘 그러면 진짜 그거 해주는 프로그램이 서버일 뿐임

Q. 유튜브 서버가 뭐임?
- 누가 동영상달라고 요청하면 동영상 보내주는 프로그램일 뿐이다.

Q. 네이버 웹툰 서버가 뭐임?
- 누가 웹툰달라고 요청하면 웹툰보내주는 프로그램일 뿐이다.

Q. 웹서버는 뭐임?
- 그냥 누가 웹페이지 달라고 하면 웹페이지 보내주는 서버일 뿐이다.

그래서 서버개발이 어려운게 아니고
누가 메인페이지달라고 하면 메인페이지 보내주고
로그인페이지 달라고 하면 로그인페이지 보내주고
그런 식으로 코드짜면 웹서버개발 끝이다.
실은 글 저장 수정 삭제 이런것도 처리해주는 기능도 있을 수 있는데 이런 것들은 나중에 해보고
이번 시간엔 간단하게 웹페이지 보내주는 서버와 그 기능부터 만들어보자.

* 서버기능 만들려면 Controller

일단 코드짜게 .java 파일을 아무데나 새로 만들어보자.
BasicController.java 라고 맘대로 작명해봤다.

package com.apple.shop;
import org.springframework.stereotype.Controller;

@Controller
public class BasicController {

}

원래 .java 파일안엔 보통 파일명과 똑같은 클래스부터 넣고 시작해야하는데
클래스는 에디터에서 알아서 생성해준다.
여기다가 이제 서버기능만들면 된다.
서버기능을 만들고 싶으면 아무 클래스에 @Controller 써놓고 시작하면 된다.

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {
    @GetMapping("/경로")
    @ReponseBody
    String hello(){
        return "유저에게 보내줄데이터";
    }
}


@GetMapping() 안에 페이지 경로 마음대로 적고
@ResponseBody 쓰고
return 오른쪽에 유저에게 보내줄 데이터를 적으면
이제 /경로로 방문했을 때 그 데이터를 보내준다.
참고로 골뱅이(@) 붙은걸 작성할 땐 엔터키 잘 쳐서 상단에서 import 해와야 동작한다.

Q. 왜 그래야함?
- Spring boot 프레임워크 사용법일 뿐이라 이렇게 쓸 뿐이다.
골뱅이(@) 잘 넣으면 알아서 서버기능이 되도록 만들어놓은 프레임워크임
심지어 골뱅이(@)만 잘 붙이면 main 함수에 안넣어도 알아서 제때 잘 실행해준다.

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {
    @GetMapping("/")
    @ResponseBody
    String hello(){
        return "안녕하쇼";
    }
}

그래서 저는 누가 / 메인페이지(@GetMapping("/"))로 접속했을 때
"안녕하쇼"라고 유저에게 메세지를 보내는 기능을 만들어봤다.
그래서 프로젝트 실행해본 다음에 브라우저켜서 localhost:8080으로 접속해보자.
이게 여러분 / 메인페이지(@GetMapping("/"))인데 접속해보면 "안녕하쇼"가 잘 나오는군요.

* 다른 페이지도 만들어보자

다른 웹사이트들 보면 메인페이지 말고 다른 페이지도 많지 않습니까 예를 들면
comic.naver.com/webtoon 으로 접속하면 요일웹툰 볼 수 있는 페이지를 보내주고
comic.naver.com/challenge 로 접속하면 도전만화 페이지 보내주고요
그런 식으로 URL을 다르게 입력하면 다른 페이지를 각각 보여준다.
우리도 이런 식으로 다른페이지하나 만들어보자.
예를 들면 누가 /about으로 접속하면 이 사이트 소개글같은거 보내주고 싶으면 어떻게해요?

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {
    @GetMapping("/")
    @ResponseBody
    String hello(){
        return "안녕하쇼";
    }

    @GetMapping("/about")
    @ResponseBody
    String about_hello(){
        return "피싱사이트에요";
    }
}

새로운 서버 기능이 하나 필요할 때 마다 @GetMapping() 덩어리 복붙해서 쓰면 된다.
    @GetMapping("/경로")
    @ReponseBody
    String hello(){
        return "유저에게 보내줄데이터";
    }

Q. 누가 /mypage 이렇게 접속하면 "마이페이지입니다" 이런 문자를 보내주고 싶으면 어떻게 하죠?

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {
    @GetMapping("/")
    @ResponseBody
    String hello(){
        return "안녕하쇼";
    }

    @GetMapping("/about")
    @ResponseBody
    String about_hello(){
        return "피싱사이트에요";
    }

    @GetMapping("/mypage")
    @ResponseBody
    String mypage_hello(){
        return "마이페이지입니다";
    }
}

* html 보내기

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {

    @GetMapping("/")
    @ResponseBody
    String hello(){
        return "<h4>안녕하쇼</h4>";
    }

//    @GetMapping("/")
//    @ResponseBody
//    String hello(){
//        return "안녕하쇼";
//    }

    @GetMapping("/about")
    @ResponseBody
    String about_hello(){
        return "피싱사이트에요";
    }

    @GetMapping("/mypage")
    @ResponseBody
    String mypage_hello(){
        return "마이페이지입니다";
    }
}

간단한 문자 말고 html을 보내고 싶으면 return 오른쪽에 html 적어도 된다.
근데 보통은 보내고 싶은 html이 매우 긴 경우엔
별도의 파일 만들어서 html 집어넣어두고 그 파일을 전송할 수도 있다.

(resources/static/index.html)

<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h4>메인페이지인데요</h4>
</body>
</html>

html css js 파일들은 resources 폴더안의 static 폴더에 보관하면 된다.
index.html 파일을 만들어서 위처럼 채워봤는데 ! 느낌표 입력하고 탭키 누르면 기본 양식이 자동완성된다.
.html 파일은 그냥 html 담는 파일이고 html은 웹페이지 만들 때 쓰는 언어임

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class BasicController {

    @GetMapping("/")
    String hello(){
        return "index.html";
    }

//    @GetMapping("/")
//    @ResponseBody
//    String hello(){
//        return "<h4>안녕하쇼</h4>";
//    }
}

유저에게 html 파일을 보내주고 싶으면 @ResponseBody 빼고 return 오른쪽에 "html파일경로" 적으면 된다.
@ResponseBody 를 쓰면 return 오른쪽에 있는걸 (문자열, html 태그 등등...) 유저에게 보내라는 뜻이고 (return "<h4>안녕하쇼</h4>";)
@ResponseBody 를 안쓰면 return 오른쪽에 있는 경로의 파일을 전송하라는 뜻이 됩니다. (return "index.html";)

파일경로는 static 폴더가 기본이다.
(예1) index.html - 기본 상위 폴더 경로가 static 폴더임
(예1) test/test.html - 기본 상위 폴더 경로가 static 폴더 하위에 속한 test 폴더임

오늘의 결론 :
웹페이지 하나 보내주는 기능 만들고 싶으면
@Controller 클래스 안에 함수하나 만들고 이거저거 채우면 만들 수 있다.

오늘의 숙제 :
누가 /date 로 접속하면 현재 날짜와 시간을 보내주는 기능을 만들어봅시다.
http://localhost:8080/date로 접속시 날짜와 시간이 대충 아무렇게나 보이면 성공이다.
굳이 HTML 말고 날짜 데이터만 보내줘도 된다.

Q. 자바에서 오늘 날짜는 어떻게 알 수 있는데요?
안배운건 검색해봐야지 생각한다고 나오는게 아님

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.text.SimpleDateFormat;
import java.util.Date;

@Controller
public class BasicController {

    @GetMapping("/")
    String hello(){
        return "index.html";
    }

    @GetMapping("/about")
    @ResponseBody
    String about_hello(){
        return "피싱사이트에요";
    }

    @GetMapping("/mypage")
    @ResponseBody
    String mypage_hello(){
        return "마이페이지입니다";
    }

    @GetMapping("/date")
    @ResponseBody
    String date(){
        // 현재 날짜와 시간 구하기
//       return LocalDateTime.now().toString();
        return ZonedDateTime.now().toString();

        // TODO: 현재 날짜와 시간 구하기 (2025.07.15 minjae)
        // 참고 URL - https://greenyellow-s.tistory.com/30
//        Date date = new Date();
//        SimpleDateFormat sdf = new SimpleDateFormat("y년 MM월 dd일 H시 m분 s초");
//        return sdf.format(date);
    }
}

LocalDateTime.now().toString() 아니면 ZonedDateTime.now().toString() 이런거 쓰면
현재 시간을 문자형태로 출력해볼 수 있다고 하는군요.
그래서 /date 접속시 보내라고 해봤더니 진짜 /date 접속시 보임

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
6강 - HTTP 요청 & REST API 개념정리

코드 배운대로 똑같이 싸지르는건 AI가 더 잘하기 때문에
큰그림이랑 원리같은걸 배워가는게 되게 중요하다.
그걸 알아야 AI에게 코딩을 시키든 말든 할거아닙니까

유저 요청 (웹페이지 내놔)-> 웹서버
웹서버 (웹페이지 전송) -> 유저

▲ 지금 하는 짓거리를 그림으로 그려보면 이렇게 생겼다.
유저가 웹브라우저를 써서 웹서버에게 이거저거 달라고 요청을 날려서 웹페이지나 데이터를 받아보고 있다.

근데 요청할 때 지켜야될 예절이 있는거 아십니까
아무렇게나 싸가지없이 웹서버에게 요청을 날리면
웹서버는 그 요청을 안들어준다.
1. method 2. URL을 정확히 적어서 예절바르게 요청을 보내야 웹서버가 답례로 데이터를 보내준다.

URL은 알아서 잘 기입하면 되고
method는 이런 것들이 있는데 이 중에서 마음에 드는거 하나 고르면 된다.
GET은 웹서버에게 데이터를 달라고할 때
POST는 웹서버에게 데이터를 보내고싶을 때
UPDATE, PUT은 웹서버에게 DB 수정요청같은걸 할 때
DELETE는 웹서버에게 DB 삭제요청같은걸 할 때
주로 고르면 된다.
그래야 웹서버는 요청을 알아듣고 이제 유저에게 데이터나 웹페이지를 응답해줄 수 있다.

@GetMapping("/경로")
@ReponseBody
String hello(){
   return "유저에게 보내줄데이터";
}

자세히 보면 웹서버기능 만들 때 여러분들이 맘대로 URL과 method를 정해놓을 수 있다.
URL은 /경로 형태로 잘 입력할 수 있고
@GetMapping 이라고 쓰면 서버에서 GET요청을 수신하겠다는 뜻이다.
Get이라고 적힌 부분은 Post, Put, Delete 이렇게 맘대로 바꿔서 코드짜놓을 수 있다.
(예) @PostMapping, @PutMapping, @DeleteMapping,

그래서 웹서버에서 맘대로 URL과 method를 정해둘 수 있는데
유저는 거기 맞춰서 요청날리면 웹서버기능을 이용가능하다.

* 요청날리는 방법

지금 요청요청 거리고 있는데 이걸 정확한 말로 HTTP 요청이라고 한다.
근데 실제로 유저가 HTTP 요청을 어떻게 날리냐고요?

GET요청하는건 쉬운데
웹브라우저 주소창에다가 URL을 때려박으면 그 URL로 GET요청을 날려준다.
엔터치면 요청이 날라가고 웹서버가 보낸 데이터를 브라우저에서 볼 수 있다.
<form> 태그나 ajax 기능을 쓰면 POST, PUT, DELETE 요청도 가능한데 나중에 알아보자..

* 웹서버에 없는 URL과 method로 요청날리면?

근데 웹서버에 기재되지 않은 URL과 method로 요청날리면 어떻게 될까요?
URL 아무렇게나 /aaaa 이렇게 입력해서 접속해보면 에러페이지가 나온다.
왜냐면 /aaaa 라는 URL로 오는 요청을 처리하는 기능은 웹서버에 안만들어놨으니까요.
그래서 유저는 당연히 웹서버에 미리 정의해놓은 URL과 method로 요청해야한다.

Q. 유저가 웹서버파일을 볼 수도 있는것도 아닌데 유저는 어떤 URL과 method로 요청해야하는지 어떻게 알죠?
그건 여러분이 나중에 웹페이지 안에 숨겨놓으면 된다.
버튼누르면 특정 URL과 method로 요청되게 만들고
사진누르면 특정 URL과 method로 요청되게 만들고
그러면 된다.
웹페이지는 그래서 실은 웹서버기능을 진열해놓은 진열장같은 역할이다.

그리고 용어 하나 배우자면
URL과 method 기재해서 작성해놓은 웹서버기능 하나를 API라고 부른다.
API는 그냥 "프로그램의 사용법"이라는 뜻인데
우리는 웹서버 프로그램을 만들고 있고 그거 하나하나가 "웹서버 사용법" 아닙니까
그래서 이걸 웹서버 API라고 부른다.

@Controller
public class BasicController {

  @GetMapping("/경로")
  @ReponseBody
  String hello(){
    return "유저에게 보내줄데이터";
  }

}

그래서 @GetMapping 부터 작성한거 하나를 API라고 부르면 된다.
그리고 API들을 담고있는 클래스는 보통 Controller라고 부른다.
유저의 요청을 여기저기 API로 안내하는 역할이라 '컨트롤러'라고 부름
그리고 아무 클래스에나 @Controller 넣어두면 해당 클래스 몸체 안에 API를 만들 수 있다는것도 잘 기억해두면 된다.

* REST API

그리고 개발하다보면 맨날 REST API 아니면 RESTful API 이런 단어들도 가끔 들린다.
자주 들리니까 이것도 뭔지 알아보도록 하자.
REST는 어떤 배나온 잡배 아저씨가 졸업논문으로 쓴 '좋은 API 만드는 법'을 의미한다.
6가지 원칙을 제안했는데

1. Uniform Interface
- 비슷한 기능을 하는 API들은 URL과 method가 유사성, 일관성이 있는게 좋다.
- 간결하고 예측가능하게 URL과 method를 만드는게 좋다.

2. Client-server 역할 구분
유저에게 웹서버역할을 맡기거나 DB를 직접 입출력하게 시키면 안좋다.

3. Stateless
셋째로 요청들은 서로 의존성이 있으면 안되고 각각 독립적으로 처리되어야한다.

4. Cacheable
웹서버가 보내는 자료들은 캐싱이 가능해야한다.
그러니까 자주 받는 자료들은 웹브라우저에서 하드에 저장해놓고
웹서버에 요청을 날리는게 아니라 하드에서 뽑아쓰는걸 캐싱이라고 한다.

5. Layered System
웹서버기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만들어도 된다고 한다.
(요청하나는 최종 응답전까지 여러 단계를 거쳐도 됩니다.)

6. Code on demand
웹서버는 유저에게 실행가능한 코드를 보낼 수 있다.

그래서 이런 원칙들을 잘 지키면서 웹서버 API를 만들면 그걸 REST아니면 RESTful API 라고 부른다.
그런데 이상한 아저씨 한명의 졸업논문일 뿐이라 근본은 별로 없는 개념이고
저걸 정확히 지키는 웹서버도 거의 없고 추상적인 포인트도 많아서 권장사항으로만 참고만 해두면 된다.

실은 요즘 와전된 다른 뜻도 있는데
원래 웹서버에서 .html 웹페이지를 보내는게 아니라 JSON 데이터만 달랑 보낼 수도 있다.
그니까 자바로 치면 Map, ArrayList 자료
자바스크립트로 치면 object랑 array 자료만 서버에서 보내주는 것이다.
그렇게 데이터만 보내는 API들을 REST API라고 부르는 경우도 있다.


Q. 웹서버에서 html이 아니라 데이터만 보내면 쓸데없는거 아님?
그럴 수 있다 웹서버에서 { product : 바지, price : 7000 } 이런 데이터만 보내봤자 뭐하겠습니까 html로 보여줘야 쓸모있지않겠습니까
근데 웹서버에서 데이터만 받아온 후에 그걸 가지고 html을 웹브라우저에서 자바스크립트로 생성하는 방법도 있다.
클라이언트 사이드 렌더링이라고 부르는데 그런 식으로도 개발이 가능해서 그렇다.
React, Vue 이런 라이브러리가 그걸 쉽게 도와주는 라이브러리이다.

* 예쁜 URL 만들기

URL 이름지을 때도 몇가지 원칙들을 지키면 이해가 쉽고 깔끔한 URL을 만들 수 있는데

- 단어들을 동사보다는 명사 위주로 구성함
- 띄어쓰기는 언더바_대신 대시-기호-사용
- 파일 확장자 쓰지 말기 (.html 이런거)
- 하위항목을 표현하고 싶으면 / 기호를 사용하면 좋다. (하위폴더같은 느낌)

예시를 한번 보도록 하자.
facebook.com/bbc/photos
instagram.com/explore/tags/food
▲ 이 URL들은 매우 잘 만든 것 같지 않습니까.

왜냐면 facebook.com/bbc/photos 여기로 GET요청하면 딱봐도 보내줄 데이터가 뭔지 느낌이 오지 않습니까
딱봐도 facebook 계정 중에 bbc 계정의 사진첩을 보여줄 것 같다.
실제로 들어가보자.

instagram.com/explore/tags/food 이건 무슨 데이터를 보내줄 것 같습니까
인스타그램 탐색페이지를 보여주는데 해시태그 #food 달린 사진만 가져다줄 것 같죠?
한 눈에 딱 보이고 깔끔하군요.

그래서 이런 식으로 깔끔하게 만드는게 좋으니 앞으로 웹서버 API에서 URL 작명할 때 한번 쯤 생각해보자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
7강 - 상품목록 페이지 만들기 (Thymeleaf)

쇼핑몰을 만든다고 했는데
가장 중요한 '상품목록 보여주는 페이지'부터 하나 만들어보자.
누가 /list로 접속하면 list.html 같은 페이지를 하나 전송해주면 될 것 같군요.
그 안엔 상품들을 집어넣고요.

* list.html 보내주는 기능을 만들어보자

(ItemController.java)

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller   // @Controller 사용하면 springframework가 알아서 아래 코드(public class ItemController { ... }) 가져와서 ShopApplication 클래스 main 함수에 집어 넣어서 아래 웹서버 코드 실행
public class ItemController {
    // 여기서 웹서버기능 제작가능

    // 웹서버 API
    @GetMapping("/list")
    String list(){
        return "list.html";
    }

}

그래서 파일(ItemController.java) 하나 새로 만들어서 웹서버 API를 만들어봤다.
- 상품과 관련된 웹서버 API들을 한 곳에 모아놓으려고 새로 파일(ItemController.java) 만들어봤다.
- 아무 클래스(예 - ItemController)에 @Controller 붙이면 웹서버 API들을 해당 클래스(예 - ItemController) 안에 만들 수 있다.
- 원래 파일(ItemController.java) 상단에 package 파일경로; 라고 적어줘야 다른 파일에서도 해당 파일(ItemController.java)에 있는 코드를 사용가능하다.

(list.html)

<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

  <div>
    <img>
    <h4>바지</h4>
    <p>7억</p>
  </div>
  <div>
    <img>
    <h4>셔츠</h4>
    <p>8억</p>
  </div>

</body>
</html>

list.html 파일도 만들어서 상품들을 채워봤다.
그럼 진짜로 /list 방문시 html 보이나 테스트해보자.

* 매번 다른 상품 보내줘야하는거 아님?

근데 이러면 접속할 때 마다 항상 같은 내용의 html 페이지만 보내주는거 아닙니까?
쇼핑몰은 맨날 다른 상품명이랑 가격을 보내야하는거 아님?
그러고 싶으면 템플릿 엔진이라는걸 사용한다.

템플릿 엔진은 웹서버의 데이터를 html에 집어넣어주는걸 도와주는 외부 라이브러리이다.
여러가지 템플릿 엔진들이 있는데 우리는 Thymeleaf 템플릿 엔진을 사용해보도록 하자.

(build.gradle)
// 설치할 외부 라이브러리들
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

위처럼 build.gradle 파일에 속한 항목 "dependencies"에 차이점(implementation 'org.springframework.boot:spring-boot-starter-thymeleaf')만 잘 붙여넣고
Load Gradle Changes 버튼누르면 외부 라이브러리 설치가 가능하다.
외부 라이브러리 설치했으면 웹서버 중지했다가 재시작해야 잘 적용된다.

* build.gradle 파일에서 외부 라이브러리 설치 방법 (Load Gradle Changes 버튼 클릭)
참고 URL - https://dawitblog.tistory.com/30

이제 html 파일을 templates 폴더(폴더 경로 - "D:\minjae\JavaSpringBootStudy\shop\src\main\resources\templates") 안에 만들어야
Thymeleaf 문법(Thymeleaf 템플릿 엔진 외부 라이브러리 설치해야 사용 가능한 문법.)으로 html을 만들 수 있다.
Thymeleaf 써도 기존 html 파일이랑 똑같이 작성하고 사용할 수 있는데
html 곳곳에 Thymeleaf 문법(Thymeleaf 템플릿 엔진 외부 라이브러리 설치해야 사용 가능한 문법.)으로 웹서버데이터를 집어넣을 수 있다는게 차이점이다.
(Node.js 웹서버의 ejs 문법과 비슷한 기능이다.)

* Thymeleaf로 웹서버데이터 html에 박아서 보내주려면

이제 웹서버에서 특정 html 파일에 웹서버의 데이터를 집어넣을 수 있는데 어떻게 하냐면
1. 웹서버 API 함수의 파라미터에 Model model 넣고
2. 웹서버 API안에서 model.addAttribute("작명", 전송할데이터); 코드 추가
3. html 파일 안에서 구현한 html 태그에 th:text="${작명}" 코드 추가
이런거 차례로 쓰면 된다.

package com.apple.shop;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller   // @Controller 사용하면 springframework가 알아서 아래 코드(public class ItemController { ... }) 가져와서 ShopApplication 클래스 main 함수에 집어 넣어서 아래 웹서버 코드 실행
public class ItemController {
    // 여기서 웹서버기능 제작가능

    // 웹서버 API
    @GetMapping("/list")
    String list(Model model) {
        model.addAttribute("name", "홍길동");
        return "list.html";
    }

}

1. 웹서버 API 함수의 파라미터에 Model model 넣고
2. model.addAttribute("작명", 전송할데이터); 쓰면 된다.
그럼 앞으로 list.html에서 name이라고 사용하면 "홍길동"이 출력된다.

(list.html)

<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

  <div>
    <img>
<!--    <h4>바지</h4>  -->
    <h4 th:text="${name}">바지</h4>
    <p>7억</p>
  </div>
  <div>
    <img>
    <h4>셔츠</h4>
    <p>8억</p>
  </div>

</body>
</html>

3. html 태그(<h4 th:text="${name}">바지</h4>)에 th:text="${작명}"(예 - th:text="${name}") 이라고 써야 웹서버에서 보낸 데이터 출력이 가능하다.
그래서 위 html을 유저에게 전송할 땐 앞으로 <h4>태그에 "홍길동"이 박혀서 전송된다.
Thymeleaf 문법(Thymeleaf 템플릿 엔진 외부 라이브러리 설치해야 사용 가능한 문법.)을 사용하고 싶으면
templates 폴더(폴더 경로 - "D:\minjae\JavaSpringBootStudy\shop\src\main\resources\templates")로 html 파일을 옮겨야 잘 동작한다.
/list 페이지 방문해서 진짜인지 실험해봅시다.

지금은 가짜 임시 데이터들을 html에 박아서 보여주고 있는데
다음 시간부터 데이터베이스를 하나 만들어서 거기 있던 데이터를 뽑아서 보내주는 방법을 알아보자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
8강 - MySQL Database 호스팅 받기

실제 서비스를 운영하려면
고객데이터 상품데이터 주문데이터 이런걸 다 저장해둬야하지 않겠습니까
엑셀이나 메모장에 저장해둬도 되긴 하는데 보통은 데이터베이스를 사용한다.
그래야 대량의 데이터를 보관해둘 수도 있고 빠르게 원하는 데이터만 입출력할 수 있으니까요.

* 관계형 데이터베이스

데이터베이스는 여러 종류가 있다.
key : value 형태로 단순하게 저장하는 것도 있고
key : value를 여러개 묶어서 document 형태로 저장하는 데이터베이스도 있고
그래프나 벡터형식을 저장할 수 있는 데이터베이스도 있다.
근데 우리는 관계형 데이터베이스를 써볼것이다.
역사와 전통이 있고 일반적으로 많이 쓰니까요.

|  id  |  price  |  title  |
|   1  |  7,000  |   셔츠   |
|   2  |  5,000  |   바지   |
|   3  |  6,000  |   자켓   |

(1) 관계형 데이터베이스는 표 형식으로 데이터를 저장해둔다.
맨 윗줄에 어떤 데이터를 저장할지 미리 기록(Column)한 다음에 하나의 행(raw)마다 데이터를 기록한다.
엑셀이랑 똑같음

(2) 데이터 입출력할 때 보통 SQL 이라는 언어를 써야 입출력이 가능하다.
하지만 우리는 ORM이라고 부르는 라이브러리를 쓸건데 그거 쓰면 자바 문법으로 데이터 입출력이 가능해서 SQL부터 익힐 필요는 없다.

(3) 여러 DBMS 중에 하나 골라서 설치하면 데이터베이스 이용이 가능하다.
한국에선 MySQL, Oracle, PostgreSQL 이런걸 자주 사용한다.
서로 저장할 수 있는 데이터의 형식, 약간의 SQL 문법이 다를 수 있는데
근데 크게 다르진 않기 때문에 아무거나 써도 별로 상관없다.
우린 MySQL을 써보도록 하자.

* 데이터베이스 호스팅받기

여러분 하드디스크에 직접 MySQL 설치해서 쓰거나
AWS 같은 클라우드 서비스가서 MySQL 호스팅을 받거나
둘 중 하나 고르면 된다.
근데 실제 서비스 운영할거면 당연히 클라우드 서비스에서 호스팅 받는게 안정적이고 좋을 것이니 그러도록 하자.

AWS / Google Cloud / 마이크로소프트 Azure 이런것들이 있다.
대부분 카드등록하면 1년 무료 사용권을 주는데
AWS는 편하게 AWS RDS에서 데이터베이스호스팅 받으려면 요즘 IPv4 이용 명목으로 월 3달러 추가요금이 발생해서
우리는 Azure 써볼것이니 여기 들어가서 가입 후 카드등록까지 해오자.

(참고) Azure는 30일 경과 후엔 직접 종량제 요금제로 업그레이드버튼 눌러야 남은 11개월동안 무료로 이용이 가능하다.

* Supabase

Supabase 들어가면 카드등록 없이 PostgreSQL 무료 호스팅을 받을 수 있다.
500MB까지 저장이 가능한데 DB입출력이 7일동안 없으면 일시정지되는게 귀찮다.
어짜피 ORM 라이브러리 쓸 것이라 PostgreSQL, MySQL 아무거나 써도 문법이 달라지지 않아서 상관 없다.
DB만들고나서 설정 들어가서
DB접속용URL, DB접속용아이디, DB접속용비번만 잘 가져와두면 된다.

* Azure에서 MySQL 호스팅받으려면

1. Azure 검색해서 들어가서 가입하고 카드등록까지 마친다.
Azure 웹사이트 URL 주소는 portal.azure.com인데 마이크로소프트 계정("minjaejeon0827@gmail.com")으로 로그인해야한다.

2. portal.azure.com 상단 검색창에서 'Azure Database for MySQL 유동서버' 검색 후 진입
그럼 만들기 버튼이 어딘가 있을텐데 눌러서 만들어보자.

3. 알아서 잘 채워준다.
- 구독/리소스 그룹은 비용관리용 폴더같은 것인데 대충 새로 만들어주자.
- 서버이름은 유니크하게 잘 작명하고 한국에서 서비스할거면 Korea 선택하자.

4. 컴퓨팅/스토리지 선택하는 곳이 있을텐데
- Compute는 무료라고 써있는거 잘 선택하시고
- IOPS는 '미리 프로비전된 IOPS' + 최소사양을 선택해야 아마 추가요금이 없습니다.
360 저건 입출력을 1초에 360회로 제한한다는 뜻이라 나중에 유저 많아지면 '자동확장 IOPS' 이런거 쓰거나 조절해보자.

참고사항 - 고가용성은 나중에 DB 안정성 높일 때 필요함.

5. DB 접속용 아이디/비번도 만들어주자.
털리면 코딩인생 끝나는 것임

DB 접속용
Host URL 주소: codingapplemysql0827.mysql.database.azure.com
아이디: codingapple
비번: qwer1234!

6. 다음 탭 눌러보면 접속가능한 IP주소도 설정할 수 있다.
- 안전하게 하려면 Azure 서버컴퓨터만 접속가능하게 '프라이빗 액세스' 이런걸 고르면 되겠지만
우리는 내 컴퓨터에서 접속해야하니까 '공용 액세스'를 고르자.
- 근데 다행히 특정 IP주소만 접속가능하게 보안장치를 하나 만들 수 있는데 여러분 IP주소 기입하면 된다.
어짜피 연습용이라 스타벅스에서 코딩할거면 모든 IP주소를 위 사진처럼 추가한다.

그럼 나머지는 건드릴거 없을거고 데이터베이스 생성하면 된다. 대충 5~10분 걸림

7. 생성되었으면 마지막으로 설정할게 하나 있음
데이터베이스 생성되었으면 들어가보면 '서버 매개 변수' 설정할 수 있는 부분이 어딘가 있을텐데
들어가서 require_secure_transport를 OFF로 설정하자.
어짜피 연습용인데 SSL 인증같은걸 잠깐 끄는 식이다.

Database 생성 끝

* AWS는요

AWS를 좋아한다면 AWS RDS 이런거 써도 되는데
올해부터 RDS 사용시 퍼블릭 액세스를 "예"로 설정하면 IPv4 사용요금 명목으로 월 3달러 정도 청구되는 것으로 바뀌어서
요금을 피하고 싶다면 AWS EC2 들어가서 인스턴스 하나 만들어서 같은 VPC그룹에 집어넣고 SSH 키파일도 가져온 다음에
SSH 터널링으로 내 컴퓨터 -> EC2 -> RDS DB 이런 식으로 접속하거나

아니면 RDS말고 EC2에 직접 설치해서 쓰면
1년무료 free tier 사용중일 경우 IPv4 요금이 아마도 청구되지 않을 것이기 때문에
EC2에서 컴퓨터 하나 빌려서 직접 MySQL 설치해서 써야합니다.
하지만 EC2에 설치하면 백업이나 모니터링 같은 것도 직접 해야하기 때문에 귀찮다.

* DB 접속은

DB 접속해서 데이터를 미리보고 싶으면
DBeaver같은 프로그램 설치하는게 가장 쉽고 빠르고 좋다.
DBeaver 검색해서 설치하면 아마 상단에 데이터베이스 연결 버튼이 어딘가에 있을텐데 눌러보자.

DBeaver 설치 방법
유튜브 참고 URL - https://youtu.be/7YEd8ECUTAk?si=Se90Wik0TuTMoX1w

DBeaver SQL 편집기 텍스트 작성시 영어 대문자 자동 적용 방법
참고 URL - https://jin2rang.tistory.com/entry/DBeaver-%EB%8C%80%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98-%EC%9E%90%EB%8F%99-%EB%8C%80%EB%AC%B8%EC%9E%90

Host 란에는 호스팅받은 데이터베이스 주소나 URL같은걸 Azure에서 가져와서 집어넣고
Username, Password 란에는 DB 접속용 아이디/비번 만든거 집어넣자.
그리고 연결눌러보면 여러분 데이터베이스에 접속해서 데이터를 구경할 수 있다.

하지만 이런 프로그램으로 접속해서 뭐함 다음시간엔 서버 코드에서 접속하는 방법을 알아보자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
9강 - 서버에서 Database 연결 & JPA 설치

일단 데이터베이스부터 만들어보자.
저번시간에 만든거 아니냐고요?
실은 저번 시간엔 MySQL이라는 DBMS 호스팅을 받은 것이고
그 안에서 데이터를 실제로 저장하려면 '데이터베이스' 하나 만들어서 거기 저장해야한다.

▲ 정확히 말하면 테이블이라는게 엑셀같은 표인데 거기 데이터를 저장한다.
근데 그걸 모아놓은 폴더같은게 '데이터베이스'임

MYSQL에서는 데이터베이스(DB)를 스키마(Schema) 라고 부른다.

* 데이터베이스 생성은

DBeaver는 상단에서 SQL편집기 어쩌구를 열 수 있는데 거기서 SQL 코드를 짜서 실행할 수 있다.

CREATE DATABASE 데이터베이스명;

거기서 이런 코드 적고 실행하면 된다.

▲ DBeaver 왼쪽 파일트리("codingapplemysql0827.mysql.database.azure.com" -> "Databases") 같은 곳에서
마우스 우클릭해서 간편하게 데이터베이스를 만들 수도 있다.
저는 shop 이름의 데이터베이스를 만들어봤다.
여기다가 테이블만들고 데이터도 넣고 그래볼 것임

하지만 DBeaver 같은 곳에서 데이터 쪼물거릴 일은 거의 없고
보통은 서버에서 코드로 데이터 입출력 하는게 일반적이다.
그래서 서버 코드에서 이 데이터베이스에 접속 하려면 라이브러리 설치가 좀 필요하다.

* JPA와 MySQL 접속용 라이브러리 설치

dependencies {
  runtimeOnly 'com.mysql:mysql-connector-j'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}

build.gradle 파일에 위처럼 dependencies 항목 추가하고 load gradle changes 버튼 누르면
JPA와 MySQL 접속도와주는 라이브러리가 설치 완료 된다.

위에 설치한 라이브러리 'com.mysql:mysql-connector-j', 'org.springframework.boot:spring-boot-starter-data-jpa' 가 필요로 하는 설정들은 아래와 같다.
spring.datasource.url=jdbc:mysql://호스팅받은곳엔드포인트주소/만든database이름
spring.datasource.username=DB접속아이디
spring.datasource.password=DB접속비번
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.properties.hibernate.show_sql=true   # JPA 문법쓸 때 SQL 따로 출력해줄지 여부
spring.jpa.hibernate.ddl-auto=update   # 코드짜서 테이블 생성(CREATE)이나 수정(UPDATE)시 그걸 자동으로 DB(데이터베이스)에도 반영할지 여부(update 해놓으면 변경사항만 반영되고 none 해놓으면 반영금지이다. none이 실제 서비스 배포 및 운영할 땐 안정적인데 update도 나쁘지는 않다.)

application.properties 파일이란?
- 웹서버 프로젝트의 환경변수, 설정(값)들을 보관하는 파일이다.

application.properties 파일에 위처럼 추가해두면 서버에서 MySQL 데이터베이스에 접속이 가능하다.
이제 서버띄울 때 Hikari pool 어쩌구 안내메세지가 뜨면 DB(데이터베이스)접속 잘 되었다는 뜻이다.

- 위의 4줄은 접속할 DB(데이터베이스)정보 입력하는 곳이고
- show_sql=true는 DB(데이터베이스)입출력시 SQL을 따로 실행창에 출력할지 여부
- ddl-auto=update는 코드짜서 테이블 생성(CREATE)이나 수정(UPDATE)시 그걸 자동으로 DB(데이터베이스)에도 반영할지입니다.

update 해놓으면 변경사항만 반영되고 none 해놓으면 반영금지이다.
none이 실제 서비스 배포 및 운영할 땐 안정적인데 update도 나쁘지는 않다.

* JPA가 뭐냐면

JPA가 뭐냐면 원래 관계형 데이터베이스는 SQL이라는 언어를 써서 데이터 입출력을해야하는데
그걸 좀 귀찮아하고 어려워하는 분들이 많다.
그래서 ORM이라는 라이브러리도 함께 설치해서 쓰는 경우가 많다.

ORM을 설치하면 SQL이 아니라 자바코드로 데이터 입출력을 해결할 수 있다.
테이블들을 클래스로 관리해서 타입체크도 되고 코드 재사용도 쉽고 여러 장점이 많다.
이거 쓰다가 마음에 안들면 직접 SQL 작성도 가능하다.

실은 지금 설치하는 라이브러리를 Hibernate라고도 부르는데
JPA는 뭐냐면 자바에서의 ORM 표준 문법같은거고
JPA 문법을 개발자들이 쓰기쉽게 만들어준게 Hibernate라는 라이브러리이다.
이게 제일 인기있어서 이거 JPA 어쩌구 설치하면 자동으로 Hibernate가 함께 설치되는 것임
그래서 JPA랑 Hibernate를 대충 혼용해서 많이 부른다.

* 왜 이건 runtimeOnly라고 쓰냐

runtimeOnly라고 적으면 코드를 컴파일할 때는 필요없는 라이브러리니까 컴파일 할 땐 쓰지말라는 소리이다.
이 라이브러리 만든 사람이 runtimeOnly라고 사용해도 상관없게 만들어놔서 그럴 뿐이다.

컴파일이뭐냐면 자바코드는 원래 실행하기 전에 컴퓨터 친화적인 바이트 코드로 변환해야하는데 그걸 컴파일이라고 부른다.
그래서 이렇게 쓰면 컴파일 되는 시간을 절약할 수 있다.
그러기 싫으면 그냥 implementation 써도 상관없다.

그래서 코드를 실제로 실행할 때만 필요한 라이브러리들은 runtimeOnly만 적어놔도 되는데
DB입출력 도와주는 라이브러리나 로그 출력용 라이브러리들이 이런걸 써도 된다.
나머지는 쓸 일이 없음

아니면 반대로 compileOnly 라고 적으면 얘는 컴파일할 때만 쓰라는 뜻이다.
그러면 개발할 때만 잠깐 쓰고 실제 서버구동시 필요없는 라이브러리들은 compileOnly 집어넣으면 나중에 용량을 절약할 수 있다.
나중에 써볼 것인데 코드 자동완성을 시켜주는 Lombok 라이브러리는 그런 식으로 설치해서 쓰기도 한다.

* Supabase 등에서 PostgreSQL 호스팅받아서 사용할 경우

dependencies {
  runtimeOnly 'org.postgresql:postgresql'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}

build.gradle 파일에 위처럼 추가하고 load gradle changes 버튼 누르면
JPA와 PostgreSQL 접속도와주는 라이브러리가 설치 완료 된다.

spring.datasource.url=Supabase에 있던 Connection string
spring.datasource.username=Supabase에 있던 User
spring.datasource.password=Supabase에 있던 Password
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.properties.hibernate.show_sql=true
spring.jpa.hibernate.ddl-auto=update

Supabase 설정 들어가보면 JDBC버전의 Connection string, User, Password 정보를 가져올 수 있다.
그거 가져다가 application.properties 파일에 입력하자.
Connection string 복붙할 때 패스워드 넣는 부분이 있으면 넣어주자.

서버가 잘 안뜨면 이런걸 확인해보자.
- DB접속 주소 잘 붙여넣었는지
- DB접속용 아이디 비번 안틀렸는지
- 아니면 MySQL의 경우엔 application.properties 파일에 주소 기재할 때 엔드포인트주소:3306/데이터베이스이름 이렇게 붙여야 잘될 수 있음
- application.properties 문자들 마지막에 이상한 공백같은거 있으면 안됨

* IntelliJ application.properties 한글 깨짐 해결 방법
참고 URL - https://velog.io/@ashappyasikonw/IntelliJ-properties-%ED%95%9C%EA%B8%80-%EC%84%A4%EC%A0%95-%ED%95%9C%EA%B8%80-%EA%B9%A8%EC%A7%90
참고 2 URL - https://www.inflearn.com/community/questions/1154446/%ED%95%9C%EA%B8%80-%EA%B9%A8%EC%A7%90-%ED%98%84%EC%83%81?srsltid=AfmBOorb4ayZpoyMxG7d8Uuz-rt0WRZTYutwGJxmCSdAfwz9MJIdk1xg

* SourceTree 사용 시 한글 깨짐 해결 방법
참고 URL - https://begindevelop.tistory.com/86

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
10강 - 테이블 만들기 (Entity)

데이터를 저장하려면 테이블 안에 저장해야한다.
그래서 상품정보들을 저장할 테이블을 하나 만들어서 쇼핑몰에서 팔 상품들을 저장해보자.

* 테이블 만들기 (@Entity)

테이블을 하나 만들고 싶으면 테이블 만드는 SQL 문법 실행하면 되는데
ORM을 쓰는 경우 그럴 필요가 없다.
자바 class하나만 만들면 테이블이 DB에도 자동생성된다.

(Item.java)

@Entity
public class Item {

}

java파일과 클래스 하나 만들어봤다.
여기다가 @Entity라는 애너테이션을 하나 집어넣으면 이 이름(Item)으로 (DBeaver - MySQL - 데이터베이스 'Shop')에 테이블을 하나 생성해준다.
JPA 라이브러리 덕분이다.

근데 테이블을 만들 때 관계형 DB들은 어떤 컬럼이 들어갈지도 미리 정해야한다.
그니까 테이블의 세로줄이 뭐가 있을지 먼저 정해야하는데
예를 들어 우리는 이 테이블에다가 쇼핑몰 상품들을 저장해둔다고 했죠?
근데 상품하나에는 어떤 정보들을 기록해두고 싶습니까

(예) 쇼핑몰 상품 테이블
| 카테고리 | 상품명 | 가격  |
|바지     |빨간바지 | 7000 |
|셔츠     |파란셔츠 | 8000 |

카테고리, 상품명, 가격 등이 있지 않을까요
그럼 하나하나의 항목들을 컬럼으로 (세로줄로) 미리 만들어두면 된다.

(Item.java)

@Entity
public class Item {
  Long id;
  String title;
  Integer price;
}

컬럼 만드는 법은 쉬운데
위처럼 클래스 안에 변수하나 만들면 이 이름으로 컬럼이 자동으로 생성된다.
그래서 상품명, 가격, 상품의 고유번호 저장할 컬럼을 만들어봤다.
나중에 상품명이 서로 같아버리면 혼란이 올 수도 있기 때문에 id같은 유니크한 번호같은걸 저장할 컬럼도 만드는게 좋다.

String 넣으면 string 저장할 수 있고
Integer 넣으면 int 저장할 수 있다.
Long 넣으면 long 저장할 수 있다.

갑자기 Integer이런거 뭐임

int 써도 int 자료를 집어넣을 수 있는데 Integer 이런거 써도 int 자료를 집어넣을 수 있다.
Integer같은 대문자 타입 쓰면
- 정수에다가 사칙연산을 쉽게 하고 싶거나
- "1" 이런 문자를 정수로 변환한다거나
- 실수같은 다른 타입으로 변환한다거나
그런걸 쉽게해주는 유용한 함수도 제공해준다.
그래서 쓰는 것임

정확히는 int 자료를 담고 있는 object인데
멋있는 말로 primitive type wrapper 라고 부른다.
실은 그냥 JPA에서 강요하기 때문에 int 말고 Integer를 쓰자.

Long은 뭐임

Integer나 int는 대충 +-20억,
Long이나 long 타입은 대충 +-900경까지의 정수를 저장할 수 있다.
그래서 상품이 20억개는 넘을 것 같아서 Long을 써봤다.
나중에 Long 타입의 숫자를 표현하려면 100L 이런 식으로 숫자 뒤에 대문자 L을 붙여줘야한다.

(Item.java)

@Entity
public class Item {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  Integer id;
  String title;
  Integer price;
}

상품 구분용 유니크 번호(정수)를 부여하기 위한 컬럼은 id 이런 식으로 작명을 많이 하고
거기다가 1, 2, 3, 4... 이런 식으로 1씩 증가하는 정수를 보통 부여한다.
UUID라는 랜덤문자로도 부여할 수도 있는데 행이 너무 많아지면 성능이슈가 생길 수 있어서 정수가 가장 간단하다.

근데 1, 2, 3, 4를 직접 하나하나 부여하기 귀찮으면 위처럼 @GeneratedValue 붙여두면
상품을 하나 추가할 때마다 알아서 1씩 증가하는 정수가 입력된다. (SQL - auto increment 기능과 유사함.)
그리고 데이터들끼리 서로 구분하기 위한 id 컬럼은 항상 @Id 라고 표기해주는게 좋다.

SQL 잘 아는 분들은
@Id는 primary key로 설정해주는 역할이고
@GeneratedValue는 auto increment 기능이라고 생각하면 된다.

* public 붙이기

(Item.java)

@Entity
public class Item {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  public Integer id;
  public String title;
  public Integer price;
}

실은 변수들을 만들면 왼쪽에 public이라고 써놔야
나중에 object 뽑은 후에 object.title 이렇게 자유롭게 출력하고 수정하고 그럴 수 있다.
근데 public 붙이면 나중에 실수해서 버그가 생기고 그럴 수 있어서 private 집어넣는걸 좋아하는 분들이 많다.

class 안에 있는 변수나 함수를 private으로 바꾸면
나중에 class에서 뽑은 object에서 맘대로 변수 함수를 점찍어서 출력하고 변경하고 그럴 수 없게 된다.
그럼 어떻게 나중에 변수를 수정하고 싶을 때 어떻게 쓰냐고요?
변수를 출력하고 수정해주는 getter 아니면 setter 함수를 만들어서 그 함수를 쓴다.
그 뻘짓거리는 나중에 같이 해보도록 하자.

주의사항 - 클래스에 속하는 변수에 public 안 붙이고 아무것도 없으면 같은 폴더내의 클래스에서만 사용가능하다.

* 제약조건 @Column으로 부여가능

컬럼마다 추가 제약사항들을 집어넣을 수 있다.

(Item.java)

@Entity
public class Item {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  public Integer id;

  @Column(length = 200)
  public String title;
  public Integer price;
}

컬럼 위에 @Column() 붙이면 제약사항들을 입력할 수 있는데
length = 200 이러면 최대 저장할 수 있는 문자 길이를 제한할 수 있다.
위처럼 코드짜놓으면 200자 넘어가면 DB저장시 실패하고 에러발생한다.

@Column(nullable = false)
이러면 이 컬럼에 데이터가 비어있을 경우 저장을 막아준다.

@Column(unique = true)
이러면 다른 행들에 없는 유니크(unique)한 데이터만 저장할 수 있다.
그니까 앞으로 유니크(unique)하지 않은게 들어오면 저장 막아주고 에러남
회원 아이디나 이메일 저장할 때 쓰는게 어떨까요

@Column(columnDefinition = "TEXT")
String만 달랑 집어넣어두면(String title;) 255자까지 저장이 가능한데 (VARCHAR(255))
매우 긴 문자를 저장하고 싶으면 MySQL같은 경우 text 타입같은게 있는데 그런거 쓰고 싶으면 여기다가 적으면 된다.

참고로 컬럼 이걸 수정을 했는데 이건 서버재시작한다고 바로 DB에 반영되지 않을 수 있다.
아마 테이블 삭제하고 서버 재시작해야 테이블에 깔끔하게 반영이 잘되니까 처음에 만들 때 잘 만들어두면 된다.
아니면 테이블 변경사항은 쌩으로 SQL 문법 짜는게 깔끔하다.

* 데이터 몇개 저장해오십쇼

DBeaver 들어가서 테이블 만든거 확인해보자.
테이블이 없으면 서버 재시작해보시고
거기 테이블에 판매할 상품들 3개 정도만 저장해보자.

insert into item values (1, '셔츠', 7000);
insert into item values (2, '바지', 5000);
insert into item values (3, '자켓', 6000);

귀찮으면 이런 식으로 SQL 코드 실행해도 테이블에 데이터를 집어넣을 수 있다.
참고로 DBeaver는 뭔가 변경사항이 있으면 저장버튼 잘 눌러야하고
새로고침해야 변경사항이 잘 보인다.

오늘의 결론 :
1. 테이블 하나 필요하면 @Entity 붙은 class 하나 만들면 자동으로 생성가능
2. 그 class에 변수 만들면 그게 자동으로 컬럼으로 변한다.
3. @id 컬럼은 항상 하나 있는게 좋다. @GeneratedValue 넣는 것도 편함
4. @Column 사용해서 컬럼마다 제약사항을 집어넣을 수 있다.

이상한데서 코딩 입문해서
새로운걸 배우면 문법 하나하나 외우려는 있는 분들이 있는데
그러면 시험합격은 잘하겠지만 우리는 시험볼 사람이 아니다.
클래스로 테이블과 컬럼을 이렇게 만들 수 있구나 그것만 외워가고
세부 문법은 필요할 때 검색해서 쓰거나 AI에게 물어보면 된다.

오늘의 숙제 :
|id  |글제목                  |날짜            |
|1   |이번 주 할인이벤트합니다   |2030년 1월 2일   |
|2   |입금자명 제발 쓰세요      |2030년 1월 2일   |
|3   |소비자브랜드상 수상       |2030년 1월 2일   |

공지사항용 글들을 저장해둘 테이블을 하나 만들어오자.
- 글의 id, 제목, 날짜를 저장할 컬럼이 필요하다. 날짜는 아무 형식이나 상관없다.
- @Entity를 활용해서 만들어오자.
- 날짜는 Date 이런 타입으로 넣으면 되긴 하는데 찾아봐도 모르겠으면 그냥 문자로 넣어도 봐드림

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
11강 - DB 데이터 출력하려면

* 잠깐 Lombok 설치

오늘 수업 진행하기 전에 라이브러리 하나만 설치하고 지나가자.
Lombok인데 필요한 코드를 자동으로 생성해줘서 자바 코드 양을 매우 줄여주는 간단한 라이브러리이다.
왜 쓰냐면 오늘 코드가 살짝 길어질텐데 코드 좀 짧게 짜려고 쓰는것임
그리고 실제로도 생산성이 워낙 좋아지기 때문에 안쓰는 곳이 거의 없다.

(build.gradle 파일)

dependencies {
  compileOnly 'org.projectlombok:lombok'   // 코드 자동생성 라이브러리 (필요한 코드를 자동으로 생성해줘서 자바 코드 양을 매우 줄여주는 간단한 라이브러리이다.)
  annotationProcessor 'org.projectlombok:lombok'
}

build.gradle 파일에 위와 같이 추가하고 버튼 "load gradle changes" 누르고 서버 재시작하면 설치 끝이다.
그리고 에디터 셋팅이 좀 필요하다.
1. 에디터 좌측 상단메뉴에 햄버거 버튼 클릭 - 파일 - Settings - Plugin 메뉴 들어가서 Lombok이라는 플러그인도 설치해야하고
2. 에디터 좌측 상단메뉴에 햄버거 버튼 클릭 - 파일 - Settings 메뉴에서 annotation processor 검색해서 "Enable annotation processing" 체크해둬야 쓸 수 있다.

참고사항 - 외부 라이브러리 설치, Lombok이라는 플러그인 설치, annotation processor 검색해서 "Enable annotation processing" 체크한 후에
          웹서버 종료 후 다시 실행 해야함.

* DB 데이터 출력

지금은 상품목록 웹페이지 가보면 임시데이터들을 html에 집어넣고 있는데
진짜 쇼핑몰처럼 DB에 있던거 꺼내서 여기 박아넣어보도록 하자.

html에 데이터 꽂는 법은 저번에 알아봤고
테이블에서 데이터 꺼내는 법만 알면 될 것 같은데
테이블에서 데이터 입출력하려면 항상 3-step 이 필요하다.

1. repository라는걸 만들고 (예) interface ItemRepository.java
2. DB입출력 원하는 클래스에서 repository를 등록하고 (예) private final ItemRepository itemRepository;
3. DB입출력문법 가져다가 쓰면 된다. (예) itemRepository.save(item);

* 1. Repository interface 만들기

일단 Entity 만든 소스파일(예 - Item.java, Notice.java) 옆에 .java 파일부터 하나 만들어줘야한다.
근데 이번엔 class 말고 interface를 만들어볼 것임

Google Gemini 사용자 질문 - "java spring boot 프레임워크에서 JpaRepository와 CrudRepository의 각각의 기능과 차이점에 대해 구체적으로 알려줘."
참고 URL - https://gemini.google.com/app/16d012e8f5315f5a

public interface 작명 extends JpaRepository<Entity명, id컬럼타입> {

}

- 파일명은 관습적으로 데이터 입출력할 Entity이름 + Repository라고 뒤에 붙여서 짓고
- 그 안에 public interface를 만들고
- <> 안에는 데이터 입출력할 Entity 이름과 그 Entity에 있던 id 컬럼의 타입(자료형 - Long, Integer 등등...)을 넣어주자.

(Item.java)

package com.apple.shop;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ItemRepository extends JpaRepository<Item, Long> {

}

그래서 전 이렇게 해봤음

Q. 왜 이렇게 써야함?
- JPA & Hibernate 만든 사람이 이렇게 쓰래요.
그냥 라이브러리 사용법이기 때문에 복붙해서 쓰면 끝이다.

이건 실은 클래스가 아니라 interface라는건데
근데 interface를 만들면 신기하게도 같은 이름을 가진 클래스(class ItemRepository)를 컴퓨터가 자동으로 생성해준다.
그 클래스 안에는 DB 데이터 입출력 도와주는 함수들이 개많이 들어있구요
그래서 그거 가져다쓰면 데이터 입출력할 수 있는 것임

이제 new ItemRepository() 하면 거기에 DB 데이터 입출력 함수들이 들어있어서 꺼내서 쓰면 된다.
근데 실은 직접 new ItemRepository() 이렇게 쓰진 않고 특별한 문법을 가져다가 쓴다.

* 2. DB입출력 원하는 클래스에서 repository를 등록하고

(Lombok 문법 사용 예시 - ItemController.java)

@Controller
@RequiredArgsConstructor
public class ItemController {
  private final ItemRepository itemRepository;

  (API들 ~~)
}

Item 테이블에서 데이터 입출력하고 싶은 클래스(예 - ItemController)가 있으면
해당 클래스(예 - ItemController) 안에 변수(private final ItemRepository itemRepository;)를 아무 이름으로 하나 만들어준다.

- 근데 타입(자료형)을 아까만든 repository 이름(ItemRepository)으로 하자.
- 해당 클래스(예 - ItemController) 위에다가 @RequiredArgsConstructor 라는 것도 추가해야하는데 Lombok 문법이다.
- private final 붙여야 잘된다.

그럼 앞으로 해당 변수(private final ItemRepository itemRepository;) 안에 DB 데이터 입출력 함수가 가득 들어있으니 그걸 자유롭게 사용하면 된다.

(Lombok 문법 사용 안하고 코드 작성한 예시 - ItemController.java)

@Controller
public class ItemController {
  private final ItemRepository itemRepository;

  @Autowired
  ItemController(ItemRepository itemRepository) {
    this.itemRepository = itemRepository;
  }

  (API들 ~~)
}

(참고) Lombok문법 쓰기 싫고 쌩으로 코드짜고 싶으면 위처럼 코드짜면 된다.
constructor(생성자 - ItemController)를 직접 적으면 되는데 귀찮으면 @RequiredArgsConstructor 라는 Lombok 문법쓰면
그 constructor(생성자 - ItemController)를 자동으로 생성해주기 때문에 안써도 되는 것이다.

이게 뭔지 간략하게만 설명하자면 그냥 스프링한테 "니가 알아서 object(객체) 하나 뽑으라고" 시키는것이다.
그럼 착한 스프링은 new ItemRepository() 해서 object(객체) 생성 후 변수(private final ItemRepository itemRepository;)에 쳐넣어준다.
그래서 위의 itemRepository 변수(private final ItemRepository itemRepository;)엔 new ItemRepository() 이런게 들어있고
앞으로 new ItemRepository()가 필요할 때 변수(private final ItemRepository itemRepository;)를 맘대로 사용하면 된다.
이런 식으로 쓰는걸 dependency injection이라고 하는데 자세한건 나중에 알아보자.

* 3. DB 입출력 문법 사용하기

(Lombok 문법 사용 예시 - ItemController.java)

@Controller
@RequiredArgsConstructor
public class ItemController {
  private final ItemRepository itemRepository;

  (API들 ~~)
}

(Lombok 문법 사용 안하고 코드 작성한 예시 - ItemController.java)

@Controller
public class ItemController {
  private final ItemRepository itemRepository;

  @Autowired
  ItemController(ItemRepository itemRepository) {
    this.itemRepository = itemRepository;
  }

  (API들 ~~)
}

위처럼 등록한 변수(private final ItemRepository itemRepository;)엔 DB 데이터 입출력 함수(예 - findAll(), save() 등등...)들이 들어있기 때문에 점찍어서 맘대로 사용하면 된다.
등록한변수.findAll() 이러면 테이블에 저장된 데이터를 다 가져와준다.
등록한변수.save() 이러면 테이블에 데이터 저장도 가능하다.

var result = itemRepository.findAll();

진짜 테이블에 저장된 데이터들 가져오나 API 아무데서나 이런거 한 번 써보고 결과도 출력해보자.

▲ 제 테이블(DBeaver - MySQL - shop 데이터베이스 - item 데이터테이블)에는 행이 3개 있는데 그걸 다 가져와주는군요.
(DBeaver - MySQL - shop 데이터베이스 - item 데이터테이블에 저장된 데이터)
| id | price | title |
|1	 |7000	 |셔츠    |
|2	 |5000	 |바지    |
|3	 |6000	 |자켓    |

[ ] 이런건 List 자료형인데 거기에 다 쳐박아서 가져오는군요.
(ShopApplication Console창 출력 결과 - List 자료형 [ ]도 같이 출력)
Hibernate: select i1_0.id,i1_0.price,i1_0.title from item i1_0
[com.apple.shop.Item@467e6d30, com.apple.shop.Item@515fd3bd, com.apple.shop.Item@4728dfc]  // List 자료형 [ ] 출력
데이터 com.apple.shop.Item@467e6d30, com.apple.shop.Item@515fd3bd, com.apple.shop.Item@4728dfc 의미 - Item 클래스의 Object 라는 뜻이다


* List 자료형

여러개의 문자나 숫자를 한 변수에 쑤셔넣고 싶으면 List 안에 쑤셔박을 수 있다.
List는 여러 종류가 있는데 보통 ArrayList를 많이 사용한다.

(ArrayList 사용 예시1)
var a = new ArrayList<>();
a.add(30);
a.add(40);
System.out.println(a);
System.out.println(a.get(0));

ArrayList 하나 만들고 싶으면 이렇게 코드짜면 된다.
- 위에서 ArrayList 라는거 import 잘 해와야 사용가능함
- ArrayList에는 .add() 라고 쓰면 안에다가 자료(데이터)를 입력(추가)할 수 있다.
- 자료(데이터)를 특정한 한개만 출력하려면 .get(순서 - 인덱스 의미) 입력하면 된다.
자료(데이터)가 ArrayList에 저장 잘 되어있는지 API 아무데나 적어서 코드를 실행시켜보자.

이게 사용법 끝임 여러 자료(데이터)를 한 객체(변수)에 쑤셔박고 싶을 때 사용하자.

(ArrayList 사용 예시2)
List<Integer> a = new ArrayList<>();
a.add(30);
a.add(40);
System.out.println(a);

var 말고 좀 더 정확히 변수의 타입(자료형)을 기재하고 싶으면 ArrayList<> 타입(자료형)(또는 List<>) 넣으면 된다.
<> 안에는 리스트에 넣을 자료들의 타입을 기재할 수 있다.
위 처럼 작성하면 Integer만 넣을 수 있는 리스트 객체(변수)(List<Integer> a = new ArrayList<>();)가 된다.

(참고1) 문자와 숫자 등 여러종류 타입(자료형)을 동시에 넣고 싶으면 Object라고 집어넣어보자. (List<Object> b = new ArrayList<>();)
(참고2) 참고로 왼쪽에 타입(자료형)을 List<어쩌구> 대신 ArrayList<어쩌구>로 기재할 수도 있다.

근데 왜 List<어쩌구> 썼는데
근데 왜 List<어쩌구> 썼냐면
원래 ArrayList랑 비슷한 타입이 몇개 있다. LinkedList 이런것도 있구요
그런것들의 상위 타입이 List이다.
그래서 List로 넣어버리면 나중에 맘대로 ArrayList, LinkedList로 필요할 때 바꾸는게 쉬워서 이렇게 쓰는 경우가 많다.
실은 그런 경우 거의 없고 List가 더 짧고 간결해보이니까 쓰는 것임

* 그래서 테이블의 한 행을 출력하려면

List<Item> result = itemRepository.findAll();
System.out.println(result.get(0))
System.out.println(result.get(0).title)

이러면 List 객체(변수) result 안에 들어있던 여러 행 중에 0번째 행(result.get(0))을 가져오고
그 중에 .title 컬럼(result.get(0).title)도 출력해볼 수 있다.
심심해서 List 객체(변수) result에 타입(자료형)도 정확히 "Item"으로 집어넣어봤다. (List<Item> result = itemRepository.findAll();)
var 자리에 타입(자료형)을 뭘 적을지 모르겠으면 var 타입(자료형)으로 선언한 변수에 마우스 올려보자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
12강 - HTML에 서버데이터 넣으려면

실은 근데 여러분들이 만드는게 서버에서 데이터만 보내주는 REST API 같은걸 만들고 있으면
"DB에 있던 데이터 뽑아서 유저에게 보내주세요~" 라고 코드짜면 끝이다.
근데 그건 초딩도 할 수 있는 것이고
진정한 남자라면 html까지 만들어서 보내주는 완전한 웹서비스를 만들 줄 알아야한다.
html에 DB 데이터를 꽂아서 보내줘보자.

* 상품목록페이지 디자인 넣기

지금 근데 /list 웹페이지(ItemController.java -> ItemController class -> @GetMapping("/list") -> list.html) 디자인이 좀 쓰레기같아서
이쁘게 좀 바꿔보도록 하자.

상품목록 레이아웃 디자인

<div class="card">
  <img src="https://placehold.co/300">
  <div>
    <h4 th:text="${name}">바지</h4>
    <p>7억</p>
  </div>
</div>
.card {
 margin: 30px auto;
 display: flex;
}
.card img {
 width: 150px;
 margin-right: 20px;
}

css처럼 생긴건 .css 파일 안에 넣고 html 파일에 <link>태그로 첨부하면 되는데
static 폴더에 main.css 같은 파일 하나 만들고

html파일 상단에 <link href=”/main.css” rel=”stylesheet”> 집어넣으면 css를 적용할 수 있습니다.

* Thymeleaf th:each 반복문

드디어 DB에서 뽑은 데이터를 html 파일(list.html)에 집어넣어보자.

(ItemController.java)

@GetMapping("/list")
String list(Model model){
  List<Item> result = itemRepository.findAll();
  model.addAttribute("items", result);

  return "list.html"
}

model.addAttribute() 쓰면 서버데이터를 html에 박을 수 있다고 했으니까
DB에서 뽑은 모든 행을 박아봤다.
result 변수는 List자료인데 그런 것도 서버에서보낸변수 "items"로 박을 수 있음

(list.html)

<div class="card">
  <img src="https://placehold.co/300">
  <div>
    <h4 th:text="${items.get(0).title}">바지</h4>
    <p>7억</p>
  </div>
</div>
<div class="card">
  <img src="https://placehold.co/300">
  <div>
    <h4 th:text="${items.get(1).title}">바지</h4>
    <p>7억</p>
  </div>
</div>

그럼 html 파일에서 첫 상품, 둘 째 상품의 title컬럼을 출력하려면 이렇게 하면 되겠군요.
근데 상품이 100개 들어있으면 어쩔 것임
이거 html 덩어리도 100번씩 복붙해야겠네요?
그러면 되는데 귀찮으면 html을 반복문으로 반복생성할 수도 있다.
Thymeleaf의 th:each 라는 반복문을 쓰면 된다.

(list.html)

<div class="card" th:each="작명: ${items}">
  <img src="https://placehold.co/300">
  <div>
    <h4 th:text="${items.get(0).title}">바지</h4>
    <p>7억</p>
  </div>
</div>

1. 반복생성하고 싶은 html 덩어리에 th:each를 붙이고
2. 안에 작명 : ${서버에서보낸변수} (예) ${items} 이런걸 채워준다.
그럼 ${서버에서보낸변수} (예) ${items}에 담긴 자료 갯수만큼 html 덩어리를 복붙해준다.

(list.html)

<div class="card" th:each="i : ${items}">
  <img src="https://placehold.co/300">
  <div>
    <h4 th:text="${i.title}">바지</h4>
    <p>7억</p>
  </div>
</div>

그리고 하나의 기능이 더 있는데
th:each 쓰면 ${서버에서보낸변수} (예) ${items}에 있던 List 안의 자료들을 꺼내서 작명한 변수 (예) i 에 넣어준다.
진짠지 출력해보자.

작명한 변수 (예) i 출력하고 싶으면 언제나 th:text 쓰면 되고 ${} 안에 변수명 (예) ${i.title} 적으면 된다.
진짜인지 테스트해보자.

* object 출력 편하게 하려면 @ToString

집가기 전에 롬복(Lombok) 라이브러리 사용법이나 더 알아보자.
object 쓰다보면 가장 불편한 점이 이건데
object.변수명 이런건 출력하면 잘나오지만
object 자체는 출력해봤자 com.apple.shop.Item@어쩌구 이런 식으로만 출력된다.

(예) (ShopApplication Console창 출력 결과 - List 자료형 [ ]도 같이 출력)
    Hibernate: select i1_0.id,i1_0.price,i1_0.title from item i1_0
    [com.apple.shop.Item@467e6d30, com.apple.shop.Item@515fd3bd, com.apple.shop.Item@4728dfc]  // List 자료형 [ ] 출력
    데이터 com.apple.shop.Item@467e6d30, com.apple.shop.Item@515fd3bd, com.apple.shop.Item@4728dfc 의미 - Item 클래스의 Object 라는 뜻이다

그래서 간혹 object에 속한 모든 변수를 한 번에 편하게 출력하고 싶으면 어떻게하게요?
쉬운 방법은 없다.
대신 여러분이 직접 "object에 속한 모든 변수를 한 번에 출력해주는 함수" 이런걸 구현하면 된다.

@Entity
public class Item {
  public Long id;
  public String title;
  public Integer price;

  public String toString(){
    return this.title + this.price;
  }
}

예를 들어 Item 클래스에 toString() 같은 함수 만들어두고
그 친구는 위에 있던 모든 변수(public Long id; public String title; public Integer price;)같은걸 출력해달라고 하면 되는 것이다.
그럼 앞으로 Item @Entity 클래스 object에다가 .toString() 붙이면 그 자리에 모든 변수가 출력되겠군요.
여러분은 개발자니까 이런거 만드는거에 거부감 느끼면 안 된다.

@Entity
@ToString
public class Item {
  public Long id;
  public String title;
  public Integer price;

}

하지만 거부감 느끼는 사람도 개발자 할 수 있는 세상인데
@ToString 붙이면 .toString() 역할의 함수를 알아서 만들어준다.
롬복(Lombok) 라이브러리 덕분이다.

(예) .toString() 함수 사용해서 Item @Entity 클래스 object 출력 예시
Item(id=null, title=null, price=null)

▲ 그럼 앞으로 Item @Entity 클래스의 object들을 출력할 때 .toString() 함수 붙여서 출력하면 이런 식으로 모든 변수(id=null, title=null, price=null)가 출력된다.
에구편해

오늘의 결론 :
1. th:each 반복문을 쓰면 html 반복생성이 가능하다.
2. 서버에서 List 자료같은걸 보내면 th:each 반복문으로 List 안에 있던 내용 하나하나 출력도 가능하다.
3. object에 속한 모든 변수들을 한번에 출력쉽게하고 싶으면 클래스에 @ToString 붙여두자.

오늘의 숙제 :
|id  |글제목                  |날짜            |
|1   |이번 주 할인이벤트합니다   |2030년 1월 2일   |
|2   |입금자명 제발 쓰세요      |2030년 1월 2일   |
|3   |소비자브랜드상 수상       |2030년 1월 2일   |

전전 강의 숙제로 이런 테이블을 하나 만들어봤다.
이 테이블에서 글을 뽑아서 보여주는 HTML 페이지를 하나 만들어보자.
앞으로 글이 많을 것이 분명하니 th:each 반복문을 써보도록 하자.

쉬워서 답은 없음
테이블의 데이터 입출력하려면 3-step이 필요하다고 했다.
그리고 .findAll()로 뽑은 데이터는 List 자료형일텐데
그걸 html에 보낼 경우 th:each 반복문으로 쉽게 출력가능하다.

참고 - 테이블에서 데이터 입출력하려면 항상 3-step 이 필요하다.
1. repository라는걸 만들고 (예) interface ItemRepository.java
2. DB입출력 원하는 클래스에서 repository를 등록하고 (예) private final ItemRepository itemRepository;
3. DB입출력문법 가져다가 쓰면 된다. (예) itemRepository.save(item);

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 1
13강 - public private protected static (access modifiers)

오늘은 재미없는 자바 기본 문법 몇 개 알아보고 지나가자.
기능구현이랑 별 상관없고 코드관리를 도와주는 문법들이다.

* public 키워드

@Entity
public class Item {
  public String title;
  public Integer price;
}

(다른 클래스)

Item item = new Item();
item.title = "바보"; //사용가능

클래스에 변수랑 함수 만들어둘 때
public을 붙일 수 있는데 그럼 이 변수와 함수는 모든 곳에서 가져다쓸 수 있다는 뜻이다.
이제 앞으로 아무 클래스에서나 .title을 출력하고 수정하고 그럴 수 있다.

* package private (접근제한자 아무것도 안붙이는 경우)

@Entity
public class Item {
  String title;
  Integer price;
}

(같은 폴더의 클래스)

Item item = new Item();
item.title = "바보"; //사용가능

클래스에 변수랑 함수 만들어둘 때
아무것도 안붙이면 package private이라고 해서
같은 폴더 안에 있는 클래스들만 이 변수, 함수를 쓸 수 있다.
남의 말 그대로 믿지말고 다른 폴더에선 사용불가능한지 테스트해보자.

* private

@Entity
public class Item {
  private String title;
  private Integer price;
}

(다른 클래스)

Item item = new Item();
item.title = "바보"; //불가능

클래스 (예) Item 에 변수랑 함수 만들어둘 때
private을 붙이면 다른 클래스에서 사용이 금지된다.
이 클래스 (예) Item 안에서만 변수랑 함수를 가져다쓸 수 있다.
클래스 바깥에서 함부로 이 변수랑 함수를 건드리지 않게 하고 싶으면 씁니다.

* protected

@Entity
public class Item {
  protected String title;
  protected Integer price;
}

(같은 폴더의 클래스)

Item item = new Item();
item.title = "바보"; //사용가능

(extends 사용해서 상속받는 클래스)
class 클래스1 extends Item {

}

protected를 붙이면 그냥 같은 폴더의 클래스에선 자유롭게 가져다가 사용가능하지만
다른 폴더로 가면 사용 불가능하다.
아까 아무것도 안붙이던거랑 동작방식이 똑같음 (package private (접근제한자 아무것도 안붙이는 경우))

하지만 이 클래스를 상속 받은 클래스가 있다면 그 친구는 어디있어도 맘대로 쓸 수 있다.
protected를 붙인 원래 클래스를 복사해서 비슷하게 생긴 클래스를 하나 더 만들 수 있다.
extends를 쓰면 복사가 가능한데 그걸 상속이라고 멋있게 부른다.

하지만 상속이라는 것을 옛날에 객체지향 개념이 처음 나왔을 땐 좋다고 많이 사용했었는데
요즘은 기피하는 사람들이 많다. (왜냐하면 상속을 많이 사용하면 소스코드 복잡해져서 싫어함. 하여 요즘은 상속보다 composition(조합) 이런거 좋아함.)
그래서 protected도 쓸 이유가 딱히 자연스럽게 없어졌다.

결론은 클래스에 변수랑 함수 만들 때 왼쪽을 비워두는 것 보다는
그냥 변수를 다른데서 못쓰게 만들고 싶으면 private 붙여놓고
다른데서 맘대로 쓰게 만들고 싶으면 public 붙여두자.

* static

@Entity
public class Item {
  public static String title;
  public static Integer price;
}

(다른 클래스)

Item.title //이렇게 사용가능

그리고 마지막으로 static 키워드도 붙일 수 있는데
이걸 붙이면 new 키워드로 object 안뽑고
클래스명에다가 점찍어서 바로 꺼내서 쓸 수 있는 변수, 함수를 만들 수 있다.

이러면 클래스에서 변수랑 함수를 복사해서 쓰는 것의 장점을 버리겠다는 소리라서
일반적인 상황에선 쓰지 않고 많은 곳에서 부담없이 쓸 수 있는 유틸리티용 함수같은거 만들 때 가끔 쓴다.
나중에 써보자.

* private 붙은 변수 수정하기

사람들이 private 쓰면 안전하다고 좋아한다.
그래서 그걸 많이 보게 될텐데 근데 private 붙여놓으면 출력조차 되지 않는다.
그럼 private 붙여놓은 변수들을 나중에 변경하고 출력하고 그러고 싶으면 어쩌냐고요?
"private 변수 출력해주는 함수"
"private 변수 수정해주는 함수"
이런걸 미리 만들어두고 그걸 가져다가 쓰면 된다.

@Entity
public class Item {
  private String title;
  private Integer price;

  public String getTitle(){
    return title;
  }
}

예를 들어 private 붙은 title 변수를 나중에 출력하고 싶어요?
그럼 출력해주는 함수 getTitle()를 하나 이렇게 만들어둡니다.
그리고 얘는 title 변수를 그 자리에 뱉으라고 해두면 되는 것임 (return title;)
이제 앞으로 title 변수를 출력하고 싶으면 .getTitle() 이러면 된다.

@Entity
public class Item {
  private String title;
  private Integer price;

  public void setTitle(String title) {
    this.title = title;
  }
}

예를 들어 private 붙은 title 변수를 나중에 수정하고 싶어요?
그럼 수정해주는 함수 setTitle(String title)를 하나 이렇게 만들어둔다.
이제 앞으로 title 변수를 수정하고 싶으면 .setTitle("수정할내용") 이러면 된다.
private 변수의 출력과 수정을 대신 해주는 함수들을 getter, setter라고 부른다.

@Entity
@Getter
@Setter
public class Item {
  private String title;
  private Integer price;
}

실은 @Getter @Setter를 변수나 클래스 위에 붙이면 getter, setter 함수를 자동으로 편리하게 만들어준다.
Lombok 라이브러리 덕분이다.

* 왜 쓰는가

근데 문법만 배우고 끝내면 아무 쓸모짝에 없고
문법을 배웠으면 왜 쓰는지 생각해봐야 나중에 활용을 할 수 있다.
왜 public안쓰고 굳이 private 붙여놓고 getter setter 만들어서 가져다쓰는 뻘짓거리를 하는 것임?

.title을 자유롭게 가져다쓰는거보다는
private 붙여놓고 getter setter 만들어쓰는게 안전한 것 같지 않습니까
그래서 사람들이 그렇게 쓰는데 예를 들어보자.

Item item = new Item();
item.title = "매우긴문자~~~~~~~~~";

(예시1)
여러분들이 나중에 .title 변수에 뭔가를 저장할 때 실수를 하면 어떻게 하죠?
예를 들어 지금은 255자 까지만 저장 가능한데 1000자가 넘는 문자를 넣거나 그럴 수도 있는 것 아닙니까

@Entity
public class Item {
  private String title;
  private Integer price;

  public void setTitle(String title) {
    만약에 title변수에 이상한 긴 문자 넣으려고 하면 차단하기~~
    if() return;
    this.title = title;
  }
}

그걸 방지하고 싶으면 변수에 private 붙여놓고 setter함수만 쓸 수 있게 만들어두고
그리고 setter 함수 안에 if 문으로 이상한 데이터를 거르는 로직을 만들 수 있겠군요.
그럼 더 안전하게 사용할 수 있지 않을까요.

(예시2)
이번엔 price 변수의 타입(자료형)을 Integer에서 Long으로 바꾸고 싶은 경우
그냥 바꿔버리면 해당 클래스 Object를 사용하는 다른 클래스에서 price 변수 쓰는 곳을 전부 다 수정해줘야하는데
setter 함수를 만들어놓은 경우에는 수정할 필요가 없이 그냥 setter 함수 안에서 타입(자료형)만 잘 변경해주면 될거같군요.

그래서 setter는 private 변수의 API를 만드는 것이랑 비슷하다.
API를 안전하게 잘 만들어두면 private 변수에 뭐 이상한걸 막 집어넣으려해도 API에서 잘 걸러줄 수 있으니까
보다 안전하게 + 안정적으로 사용할 수 있다.

그래서 좋다길래 그냥 모든 변수에 기본 setter를 전부 대충 만들어두고 쓰는 사람이 있는데
검사로직이 추가되면 안전하게 쓸 수 있는 것이라 setter만 집어넣으면 귀찮기만 할 수 있다.

* 오늘 배운거 요약

클래스 안에 변수, 함수 만들 때
private, public, static 중에 골라넣으면 되는데
1. 다른 클래스에서 변수랑 함수 쓸 수 있게 만들거면 public
2. 다른 클래스에서 변수랑 함수 못쓰게 만들거면 private
3. 유틸리티 함수같은거 만들 때는 static 쓴다.

근데 private 넣어두고 getter, setter 만들어서 쓰면 장점이 있기 때문에 그렇게 쓰는 사람이 많다.

오늘의 숙제 :
1. 이름과 나이를 저장할 수 있는 클래스를 하나 만들어두고
object를 하나 뽑아서 여러분의 이름과 나이를 저장해보자.
근데 클래스 안의 변수들을 private 변수로 만들어서 사용해보자.

2. 방금 만든 클래스에서 나이를 +1 하는 함수와 나이를 바꿔주는 함수를 각각 만들어서 사용까지 해보자.
(ShopApplication.java 소스파일 -> main 메서드에서 아래처럼 구현하기)
var object = new 클래스();
object.한살더하기();
object.나이설정(12);

(동작예시)
한살더하기()를 사용시 object에 저장된 나이가 +1 되어야한다.
나이설정(12)를 사용시 object에 저장된 나이가 12로 변경되어야한다.

3. 위에서 만든 함수를 사용할 때
나이가 음수가 되거나 100살 이상이 되는 경우를 막아주도록 함수를 업그레이드해보자.
예를 들어 나이설정(-10) 이라고 사용하면 나이가 변동되지 않아야한다.

4. Item class의 변수들도 전부 private로 만들어서 사용해보자.
그럼 그 private 변수들을 쓰는 곳들을 다 수정해줘야겠군요.
그건 알아서 해보자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
14강 - 상품 추가기능 1 (Map 자료형)

오늘의 숙제 :
서버는 데이터 받으면 Item 테이블에 저장해주는 기능을 완성해오자.

쇼핑몰을 운영할거면 내가 팔고싶은 상품을 하나 맘대로 추가할 수 있는 기능도 있어야겠군요
상품을 하나 추가하는 기능을 만들어보자.
실은 거의 모든 웹서비스는 게시판과 똑같아서
게시판 글 추가기능이라고 생각해도 되는데 실은 알아서 다 할 수 있다.

선생코드 외워서 베끼는걸 코딩이라고 생각하는 분들이 있는데
코드는 원래 혼자 알아서 짜는것이다.

Q. 안배운건데 코드를 내가 어떻게 짜요?
- 이 기능이 어떻게 동작하는지 한글로 설명부터 적은 후 그대로 번역만 하면 된다고 기초강의에서 많이 강조했다.

* 상품 추가기능을 글로 적어보면

그래서 상품하나 추가하는 기능을 글로 설명부터 해보면
1. 상품추가하는 페이지 하나 만들고 폼도 만들어놓고
2. 전송버튼 누르면 그 내용을 DB로 보내서 저장
이게 끝 아니겠습니까

근데 이러면 문제가 하나 있다.
유저가 마구 작성한걸 DB에 바로 집어넣어버리면 좀 위험하지 않을까요?

그래서 항상 DB 조작이 필요하면 중간에 서버가 개입해서 이거저거 검사해주는게 좋다.

1. 글작성페이지 하나 만들고 인풋과 폼 만들어놓고
2. 유저가 전송누르면 글을 서버로 먼저 보내고
3. 그 다음에 서버는 글을 검사 후 별일 없으면 DB에 저장
저는 이렇게 적어봤고 이제 코드로 번역만 하면 되겠군요.
모르는게 나오면 구글에게 물어보면 된다.

* 1. 글작성페이지 만들기

(write.html)

<form>
  <input name="title">
  <input name="price">
  <button type="button">전송</button>
</form>

대충 다른 html 파일이랑 비슷하게 만들어두고
<body>태그 안에 <form> 하나를 추가해봤다.
상품 이름이랑 가격을 입력할 수 있는 <input>도 마련해봤다. (<input name="title"> <input name="price">)
input 만들 때 중요한게 name 속성을 잘 작명해놔야 서버로 전송이 된다.

이걸 이제 유저들에게 어떻게 보여줄거에요?
html 웹페이지 보내주고 싶으면 API를 하나 만들면 된다.

// 웹서버 API
@GetMapping("/write")
String write() {
  return "write.html";
}

누가 /write로 접속하면 글작성 페이지를 보내라고 해봤다.
/write 접속해서 진짜 나오나 테스트해보자.

* 2. 전송누르면 서버로 글 전송

HTTP POST 요청을 날리면 웹페이지에서 사용자가 작성한 문자나 숫자를 서버로 전송할 수 있다.
POST요청은 어떻게 날리냐면 <form>에 잘 뭔가 기입하면 되는데

(write.html)

<form action="/add" method="POST">
  <input name="title">
  <input name="price">
  <button type="button">전송</button>
</form>

action="/URL"과
method="POST"를 기입하면
전송버튼(<button type="button">전송</button>) 눌렀을 때 특정 /URL로 POST요청을 날릴 수 있다.
근데 웹서버에 만들어둔 API와 URL이 없어서 아무렇게나 /add로 작명해놨다.

* 3. 서버는 데이터 받으면 확인 후 DB저장

// 웹서버 API
@PostMapping("/add")
String writePost() {
 return "";
}

API를 하나 만들어보자.
@PostMapping 으로 바꾸면 유저의 HTTP POST 요청을 처리하는 API를 만들 수 있다.
참고로 @DeleteMapping, @PutMapping 이런 식으로 쓰면 DELETE, PUT 요청도 처리하는 API를 만들 수 있다.
여기서 유저가 보낸 데이터를 웹서버가 이거저거 출력하고 검사해보고 DB에 저장해주면 되는거 아닙니까

* 유저가 보낸 데이터 출력은

// 웹서버 API
@PostMapping("/add")
String writePost(String title, Integer price) {
  return "";
}

유저가 보낸 데이터를 웹서버 API 함수에서 출력하려면
웹서버 API 함수 소괄호 안에 파라미터를 잘 적으면 되는데

위에 <input>보시면 title, price 라는 이름으로 인풋 데이터들을 보내고 있지 않습니까 (<input name="title"> <input name="price">)
그걸 그대로 웹서버 API 함수 소괄호 안의 파라미터란에 적어주면 유저가 보낸 title, price를 파라미터 변수에 담아준다. (String writePost(String title, Integer price))
그리고 왼쪽에 타입(String, Integer)을 적으면 그 타입으로 title, price 변수를 각각 변환해준다. (String writePost(String title, Integer price))

@PostMapping("/add")
String writePost(@RequestParam String title, @RequestParam Integer price) {
 return "redirect:/list";
}

- 안되면 왼쪽에 @RequestParam 붙여보자.
- redirect:/list 이러면 특정 웹페이지(/list)로 유저를 강제 이동시킬 수 있다. (ajax로 요청하는 경우 이동불가능)

(참고1) @RequestParam 생략이 안된다면
파일 - 설정 - java compiler 메뉴 검색해본 후에
additional command line parameter 입력란에 -parameters 입력잘되어있는지 확인해보자.
out 폴더도 삭제 후 다시 서버 띄워보자.

(참고2) <form> 말고 ajax의 body로 전송한 데이터는 @RequestBody라는걸 써야 출력해볼 수 있는데 나중에 알아보자.

(참고3) 유저가 보내는 데이터가 100개면 웹서버 API 함수 소괄호 안에 파라미터도 100개 적어야되는데
그게 귀찮으면 Map 자료형에 한 번에 담으라고할 수도 있다.

@PostMapping("/add")
String writePost(@RequestParam Map<String, Object> formData) {
 return "redirect:/list";
}

Map 자료형도 List처럼 자료 여러개를 한 변수에 저장하고 싶을 때 쓰는 자료형인데
어떻게 쓰는지 알아보자.

* Map 자료형

변수 하나에 내 이름과 주소를 저장하고 싶으면 어떻게 하죠?
List 써서 다 쑤셔넣는 방법도 있는데 엘레강스하게 저장하고 싶으면 Map을 만들어서 쓰셔도 된다.

Map test = new HashMap<>();

- Map 변수 = new HashMap<>(); 쓰면 Map 자료형 변수를 하나 만들 수 있다.
- 변수.put() 이용하면 Map 자료형 변수 안에 데이터를 집어넣을 수 있다.

Map test = new HashMap<>();
test.put("name", "kim");
test.put("address", "seoul");

- List랑 다르게 자료마다 이름을 붙여서 저장해야한다. 변수.put("자료이름", "자료값")
- 멋있는 말로 자료 이름은 key, 자료 값은 value라고 부른다.
진짜 저장되는지 test 변수 출력도 해보자.

Map test = new HashMap<>();
test.put("name", "kim");
test.put("address", "seoul");
System.out.println(test.get("address"));

- 자료 하나 출력은 변수.get("자료이름") 쓰면 된다.

Map<String, String> test = new HashMap<>();
test.put("name", "kim");
test.put("address", "seoul");

- 그리고 저장할 자료의 타입을 엄격하게 제한하고 싶으면
<자료이름타입, 자료값타입> 이렇게 잘 적어두자. (Map<String, String> test)
원래 <> 2개에 전부 넣어줘야하는데 귀찮으면 왼쪽에만(Map<String, String> test) 넣으면 오른쪽에도(new HashMap<>();) 알아서 들어간다.

(참고1) 가끔씩 문자나 숫자를 전부 저장하고 싶거나 그런 경우엔 Object라고 쓰면 된다.
Object는 String Integer 이런 것들의 상위타입(부모 클래스 or 조상 클래스)이라 그렇다.

(참고2) Map은 2종류가 있는데 그 중에 HashMap을 자주 사용한다.
그리고 그것들의 상위 타입(부모 클래스 or 조상 클래스)이 Map이라서 Map타입이라고 기재하는 경우가 많다.
그러면 다른 종류의 Map으로 전환이 쉬워진다. (전환할 일 없음)

오늘의 숙제 :
서버는 정보(데이터) 받으면 Item 테이블에 정보(데이터) 저장해주는 기능을 완성해오자.
폼 전송시 그 정보(데이터)들이 Item 테이블에 추가되면 성공이다.
JPA로 테이블에 정보(데이터) 저장하는 문법을 모르겠다면 구글과 AI에게 물어봐야지 생각한다고 나오는게 아님

JPA save 함수 (테이블에 정보(데이터) 저장해주는 기능)
참고 URL - https://wikidocs.net/161396
참고 2 URL - https://gaga-kim.tistory.com/309
참고 3 URL - https://itconquest.tistory.com/entry/Spring-Boot-JPA%EC%99%80-Hibernate
참고 4 URL - https://isaac-christian.tistory.com/entry/Spring-Boot-JPAJava-Persistence-API-Hibernate-Spring-Data-JPA
참고 5 URL - https://velog.io/@dnrwhddk1/3.-SpringBoot%EC%97%90%EC%84%9C-JPA%EB%A1%9C-DB-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B0%84%EB%8B%A8%ED%95%9C-API-Auditing
참고 6 URL - https://dsc-sookmyung.tistory.com/596
참고 7 URL - https://terianp.tistory.com/166
참고 8 URL - https://velog.io/@qweadzs/3.-Spring-boot-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%97%90%EC%84%9C-JPA%EB%A1%9C-DB%EB%A5%BC-%EB%8B%A4%EB%A4%84%EB%B3%B4%EC%9E%90

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
15강 - 상품 추가기능 2 & Navbar 만들기

* 저번시간 숙제

유저가 제출한 내용(데이터)을 이거저거 검사해본 다음에 Item 테이블에 데이터 저장하는 기능을 만들어보자.
테이블에 데이터 저장하는건 어떻게 하냐면
new Item()으로 생성한 변수에다가 여러가지 정보(데이터)를 채운 다음에
리포지토리.save() 함수 소괄호 안에 new Item()으로 생성한 변수를 넣으면 그 정보(데이터)들을 채워서 행을 하나 테이블에 데이터로 추가해준다.

(ItemController.java)

@PostMapping("/add")
String writePost(String title, Integer price) {
  Item item = new Item();
  item.setTitle(title);
  item.setPrice(price);
  itemRepository.save(item);
  return "redirect:/list";
}

그래서 해봤다.
저는 Item 클래스에 속하는 멤버변수에 private을 붙여놨기 때문에 setter 함수를 사용해서 데이터를 집어넣었다.
진짜 저장 잘 되는지 테스트도 해보자.

* 유저가 보낸 데이터를 object로 쉽게 변환하려면 @ModelAttribute

가끔 유저가 웹서버 API 함수로 보낸 데이터를 object로 바로 변환하고 싶을 때가 있다.
그럼 편리할 것 같지 않습니까

(ItemController.java)

@PostMapping("/add")
String writePost(@ModelAttribute Item item) {
  itemRepository.save(item);
  return "redirect:/list";
}

그러고 싶으면 @ModelAttribute 클래스명 변수명 이렇게 작성하면 (@ModelAttribute Item item)
var 변수명 = new 클래스명() 을 알아서 해주고
그 변수에 유저가 웹서버 API 함수로 보낸 데이터를 다 집어넣어준다.
남의 말 믿지 말고 진짜인지 item 변수 출력해보자.

* Navbar 만들기

오늘은 상단메뉴(Navbar)를 만들어보자.

<div class="nav">
  <a class="logo">SpringMall</a>
  <a>List</a>
  <a>Write</a>
</div>

(main.css)
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;800&display=swap');
.nav {
 display: flex;
 padding: 10px;
 align-items: center;
 font-family : 'Montserrat';
}
.nav a {
 margin-right: 10px;
 text-decoration : none;
 font-weight : 400;
 letter-spacing : -0.5px;
}
.nav .logo {
 font-weight : 800;
}

input, button {
 padding : 8px 13px;
 margin-top : 5px;
 border : 1px solid grey;
 border-radius : 4px;
 vertical-align : middle;
}
button {
 background : black;
 color : white;
 border : none;
}
input {
 display : block;
}

복붙하면 Navbar가 생성된다.
밑에 button, input 디자인용 CSS도 넣어봤다.

근데 잘 생각해보면 Navbar를 여러 웹페이지에 매번 복붙하는게 힘들지 않겠습니까
웹페이지가 몇 개 없으면 손수 복붙해도 되긴 하는데
그럼 나중에 Navbar 수정이 필요하면 복붙해놨던 모든 html 웹페이지를 수정해야겠군요.
그게 싫으면 웹페이지마다 재사용하고 있는 UI(Navbar)를 별도 파일로 뺀 다음에 이걸 가져다 쓰는 식으로 개발하면 된다.
타임리프(Thymeleaf) 템플릿 엔진 문법 쓰면 쉽게 가능하다.

* HTML UI 재사용하기

templates 폴더에 재사용할 html 덩어리를 보관할 파일(nav.html)을 하나 만들어보자.

(nav.html)

<div class="nav" th:fragment="navbar">
  <a class="logo">SpringMall</a>
  <a>List</a>
  <a>Write</a>
</div>

이런 html 덩어리를 재사용하고 싶으면
th:fragment="작명" (th:fragment="navbar")
입력해두면 되는데 그럼 다른 파일에서 이 html 덩어리를 쉽게 쓸 수 있다.

(다른 html 파일 - (예) list.html)

<div th:replace="~{nav.html :: navbar}"></div>

(다른 html 파일 - (예) list.html)에서 th:replace="~{파일경로 :: fragment이름}" 이렇게 쓰면 (th:replace="~{nav.html :: navbar}")
그 파일경로에 있던 th:fragment를 가져다가 첨부해준다. (th:fragment="navbar")
그래서 위처럼 작성하면 div태그 내용물을 th:fragment="navbar" 붙은 html 덩어리로 갈아치워준다. (th:replace="~{nav.html :: navbar}")

(참고1) th:insert 사용하면 div를 갈아치우는게 아니라 div 안에 붙여넣어준다.
근데 갈아치우는게 일반적임

(참고2) th:fragment 정의는 한 파일에 여러번 사용해도 된다. (예) - nav.html 파일 안에 여러번 사용 가능

(참고3) html 덩어리((예) nav.html)로 변수나 데이터같은걸 전송해줄 수도 있다.
th:replace="nav.html :: navbar('데이터1', '데이터2')"
이러면 되는데 이런게 가능하다고만 알아두자.
어짜피 까먹으니 세부문법은 나중에 필요하면 찾아쓰자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
16강 - 상세페이지 만들기 1 (Optional)

오늘의 숙제 :
하단 참고

심심하니까 상품마다 상세페이지를 만들어보자.
상품명을 클릭하면 상세페이지로 이동시키면 될거같은데
한글로 설명부터 적어보도록 하자.
근데 상세페이지가 어떤 식으로 동작하는지 모르겠어서 설명도 못하겠으면 다른 사이트들을 참고하면 된다.

* 다른 쇼핑몰은 어떻게 동작하나

예를 들어 11st.co.kr/mart/category?categories=1120865 이런 쇼핑몰의 상세페이지를 구경해보자.
(예) 상품 상세 웹페이지 11st.co.kr/products/4284278427

▲ 위처럼 /products/어쩌구(상품번호)로 접속하면 상품 상세 웹페이지를 보여준다.
근데 어쩌구 부분은 상품번호 아닐까요?
여러개 눌러보면 그런 것 같다.

그래서 우리도 이 방식과 비슷하게 웹서버 API나 웹페이지들을 만들면 될 것 같군요.
누가 /detail/1 로 접속하면 1번 상품 보여주고
누가 /detail/2 로 접속하면 2번 상품 보여주고
그래보자.
1번 상품이 뭐냐면 Item 테이블에 있던 컬럼 id의 값이 1인 상품이다.

근데 그럼 지금 상품이 4개 있으니까 웹페이지가 4개 필요하고 그럼 웹페이지 보내주는 웹서버 API도 4개 만들어야겠네요?
그러면 된다.
근데 상품이 100만개 있으면 어쩔거에요?
웹서버 API를 100만개 만들어야하는데
URL 파라미터라는 문법을 쓰면 굳이 비슷한 URL 가진 웹서버 API들을 여러개 만들 필요가 없다.

* URL 파라미터

@GetMapping("/detail/{id}")
String detail() {
  return "detail.html";
}

서버에서 URL을 정할 때 {작명} (예) {id} 이런걸 사용하면 아무 문자라는 뜻이 된다.
그래서 위처럼 작성하면 누가 /detail/ 뒤에 아무 문자나 입력하면 이 웹서버 API가 실행된다.

그럼 웹서버 API들을 100만개 직접 만들 필요가 없어지죠?
그래서 비슷한 URL가진 웹서버 API가 여러개 필요하면 이런 문법 씁시다.

- 작명은 진짜로 아무렇게나 가능
- 여러개 동시 사용가능 (슬래시로 서로 구분하는게 좋음)

* detail.html 만들기

detail.html 웹페이지 보내주라고 한 것 같은데 (return "detail.html";)
이 웹페이지도 하나 만들어보자.

상세 웹페이지 HTML CSS 레이아웃

<div class="detail">
  <h4>상세페이지</h4>
  <img src="https://placehold.co/300">
  <h4>금도금 바지</h4>
  <p>7억</p>
</div>

.detail {
  text-align : center;
}
.detail img{
  max-width : 30%;
  display : block;
  margin : auto;
}

/detail/1
/detail/2
/detail/3
웹브라우저에서 이런 경로로 접속해보자. 진짜로 상세 웹페이지 나오죠?

Q. 근데 매번 똑같은 html 내용만 보여주고 있는데요?
- 상품이 4개니까 html 파일도 상품마다 하나씩 총 4개 각각 만들어두면 된다.
근데 굳이 그럴 이유가 없는게
html 전송할 때 html에 매번 다른 데이터를 박아서 보여줄 수 있다고 배운 것 같은데 그렇게 하면 된다.

* DB에서 글 뽑아서 html에 박아보자

누가 /detail/1로 접속하면 1번 상품 DB에서 가져와서 html에 박아 보여주고
누가 /detail/2로 접속하면 2번 상품 DB에서 가져와서 html에 박아 보여주고
그래보자.

1번 상품은 컬럼 id의 값이 1로 저장되어있는 상품인데
컬럼 id의 값이 1인 행(Raw)을 테이블에서 어떻게 출력하죠?
안배운건 검색해봐야 나온다.

"jpa에서 id로 찾아오기~" 이런거 검색해보면 되겠네요.
근데 요즘은 구글보다 AI 검색 툴이 훨씬 나은 것 같다. (GPT는 원래 검색툴이다.)
요즘은 검색하면 학원강의 그대로 받아적은 게시물밖에 안보임

@GetMapping("/detail/{id}")
String detail() {
  var result = itemRepository.findById(1L);
  return "detail.html";
}

리포지토리.findById(1L) 이러면 id가 1인 행(Raw)을 찾아온다는군요.
참고로 숫자를 Long 타입으로 만들고 싶으면 뒤에 L 적으면 된다.
이걸 변수(result)에 저장해서 이제 html에 보내면 될거같은데 근데 var 자리에 타입(자료형)은 뭘 넣어야하게요?
모르겠으면 변수(result)에 마우스 올려보면 된다.
Optional 이런 타입(자료형)을 넣으라는군요.

* Optional 타입

Optional은 변수에 할당된 값이 null일 수도 있고 아닐 수도 있다는 타입(자료형)이다.
DB에서 찾은걸 왜 이런 타입(자료형)으로 변형해주냐면
가끔 DB에 컬럼 id의 값이 1인 행(Raw)이 없을 수도 있는거 아닙니까?
그럴 땐 null 혹은 텅빈 값이 아마 이 변수에 들어올것이다.
그래서 JPA 만든 사람이 변수에 할당된 값이 null일수도 있으니까 조심해서 쓰라고 만들어준 타입(자료형)이다.

@GetMapping("/detail/{id}")
String detail() {

  Optional<Item> result = itemRepository.findById(1L);
  System.out.println(result.get());
  return "detail.html";
}

Optional 자료(데이터)는 .get() 붙여야 안에 들어있는 자료(데이터)가 나온다. (result.get())
물론 result 변수에 값이 비어있을 수 있기 때문에(변수에 할당된 값이 null인 경우) 그냥 .get() 하고 그러면 웹서버가 에러나고 동작이 멈출 수 있다.
그래서 "만약에 result 변수 안에 할당된 값이 뭐가 있는 경우에만 .get() 해서 사용해라" 이렇게 쓰는게 안전하고 좋다.

@GetMapping("/detail/{id}")
String detail() {

  Optional<Item> result = itemRepository.findById(id);
  if (result.isPresent()){
    System.out.println(result.get());
    return "detail.html";
  } else {
    return "~~~";
  }
}

Optional타입(자료형)result변수.isPresent() 라고 쓰면 result변수 안에 할당된 값이 뭐가 들어있으면 true를 그 자리에 남겨준다.
그래서 위처럼 쓰면(if (result.isPresent())) 확실하게 값이 들어있을 경우에만 .get() 해서 데이터를 안전하게 사용할 수 있다. (result.get())
근데 if 안쓰면 에디터가 알아서 잡아줘서 외우고 그럴 필요는 없다.

아무튼 result.get() 출력해보면 DB에서 뽑은 컬럼 id의 값이 1인 1번글 내용이 나오는데
이걸 그대로 html 파일에 박아서 진짜 상세페이지처럼 만들어보는건 여러분들이 알아서 숙제로 해옵시다.

오늘의 숙제 :
상세 웹페이지를 마저 완성해오자.
/detail/1로 접속하면 컬럼 id의 값이 1인 상품의 제목과 가격이 잘 보여야한다.
심심하면 상품제목 누르면 상세페이지로 이동하는 링크도 만들어봅시다.

(힌트) 유저가 URL 파라미터에 마구 입력한 값을 서버에서 쉽게 알 수 있는데
@PathVariable 이라는걸 찾아보면 되겠다.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
17강 - 상세페이지 만들기 2 & 예외처리

* 상세페이지 완성해오라던 숙제

저번시간 숙제나 먼저 해보자.
지금 Item 테이블에서 상품하나를 가져오고 있는데 지금은 어떤 URL로 접속하든 1번 상품만 가져오고 있다.
/detail/1로 접속하면 1번 상품
/detail/2로 접속하면 2번 상품
가져오는게 좋지 않을까요 그리고 그걸 html에 집어넣으라고 코드짜면 상세페이지 완성이겠군요.

@GetMapping("/detail/{id}")
String detail(@PathVariable Long id) {

  Optional<Item> result = itemRepository.findById(id);
  if (result.isPresent()){
    return "detail.html";
  } else {
    return "redirect:/list";
  }
}

(@PathVariable 타입[자료형] URL파라미터명) 이라고 잘 작명하면 (예) @PathVariable Long id
URL 파라미터 자리(id)에 유저가 입력한 내용을 가져올 수 있다.
그래서 위처럼 코드짜면 /detail/x로 접속하면 x번 상품을 잘 가져오는거 같다.
지레짐작해서 코딩하는건 매우 나쁜 습관이니 진짜 잘되는지 출력해보는게 좋은 습관이다.

@GetMapping("/detail/{id}")
String detail(@PathVariable Long id, Model model) {

  Optional<Item> result = itemRepository.findById(id);
  if (result.isPresent()){
    model.addAttribute("data", result.get());
    return "detail.html";
  } else {
    return "redirect:/list";
  }
}

DB 테이블에서 가져온 데이터를 detail.html에 꽂으라고 코드짜봤다.

(detail.html)

<div class="detail">
  <h4>상세페이지</h4>
  <img src="https://placehold.co/300">
  <h4 th:text="${data.title}">금도금 바지</h4>
  <p th:text="${data.price + '원'}">7억</p>
</div>

detail.html에 방금 서버에서 보낸 data 변수를 박아넣어봤다.
진짜 잘 보이나 /detail/1 이런거 접속해보자.

* 링크만들기

하지만 유저는 바보 멍청이라 직접 /detail/1 입력을 못한다.
대신 클릭 이런건 잘하기 때문에
상세페이지로 접속할 수 있는 링크를 개발자가 친절하게 만들어주면 되겠다.
<a href="/url"> 사용하면 사용자가 클릭시 /url로 웹페이지가 이동한다.

(list.html)

<div class="card" th:each="i : ${items}">
  <img src="https://placehold.co/300">
  <h4 th:text="${i.title}">바지</h4>
  <a href="/detail/1">링크</a>
  <p th:text="${i.price + '원'}">7억</p>
</div>

그래서 list.html 페이지에 이런 식으로 링크를 만들었는데 이러면 안되겠죠?
이러면 모든 글을 누르면 항상 /detail/1로 이동한다.

1번 상품에는 href="/detail/1"
2번 상품에는 href="/detail/2"
3번 상품에는 href="/detail/3"
이런 식으로 채워야하지 않겠습니까

href="/detail/현재상품의id"
이렇게 코드짜면 될거같다.

현재 상품의 id는 반복문에 있던 i라는 변수 출력해보면 아마 거기 안에 들어있지 않을까요 (예) i.id

(list.html)

<div class="card" th:each="i : ${items}">
  <img src="https://placehold.co/300">
  <h4 th:text="${i.title}">바지</h4>
  <a th:href="@{'/detail/' + ${i.id} }">링크</a>
  <p th:text="${i.price + '원'}">7억</p>
</div>

href 안에 변수나 서버에서 보낸 데이터를 쑤셔넣고 싶으면 이렇게 하자. (예) href="@{'/detail/' + ${i.id} }"
- 보통은 서버에서 보낸 변수를 넣고 싶으면 ${ } 안에 넣으면 되는데 근데 href안에는 @{ } 부터 시작하면 됩니다. (예) href="@{'/detail/' + ${i.id} }"
- 보통은 서버에서 보낸 변수를 넣고 싶으면 ${ } 안에 넣으면 되는데 근데 href 속성 안에는 Thymeleaf 템플릿 엔진 사용해서 @{ } 부터 시작하면 된다. (예) href="@{'/detail/' + ${i.id} }"
- 문자는 작은 따옴표 안에 넣어도 됩니다. (예) '/detail/'
- 문자들을 합치고 싶으면 + 기호 쓰면 됩니다. (예) '/detail/' + ${i.id}

URL 링크 잘 동작하나 확인해보자.
html이 잘 완성되어있는지 확인하고 싶으면 언제나 크롬(Chrome) 개발자도구 열어서 html 검사해볼 수 있다.

* 예외상황 처리하기

서버개발할 땐 항상 예외상황을 가정하고 코드짜는게 좋다.
글 발행 기능 비슷한걸 하나 만들어놨는데 유저가 이상한 데이터를 보내면 어쩔 것임?

예를 들어서 상품명을 빈칸으로 보내거나
없는 상품의 상세페이지를 들어가거나 그런 경우들이 있겠군요.

이거 말고도 예외 상황이 매우 다양하기 때문에
여러분들이 직접 악성 유저가 되어서 이거저거 테스트해보고
예외 상황마다 그걸 대처하는 코드를 if문으로 걸러주면 훨씬 안전한 서버가 완성된다.
서버만들 때는 그런거 안하면 코딩 인생이 금방 끝나니까 하는 것임

* 에러발생시

근데 if문으로 부족한 경우가 있다.
가끔가다가 코드에서 에러가 나는 경우도 있는데 그런 것도 처리해야 한다.

- 유저가 보낸 데이터가 숫자형식이어야 하는데 문자를 보냈거나
- DB에 너무 긴 데이터를 집어넣거나
- DB가 꺼져있거나

이러면 코드들에서 에러가 나서 동작이 멈출 수 있다.
강제로 에러를 내보고 싶으면 throw new Exception() 이런거 써보면 된다.
아니면 더 간단하게 타입(자료형)이 틀린걸 전송해봐도 에러를 체험해볼 수 있다.

예를 들어 /detail/abc 이런 식으로 접속해보면
abc 라는 문자열을 Long타입(자료형)으로 변환할려고 하는데 그건 불가능해서 아마 서버에서 에러가 난다.

에러가 나면 친절하게 기본 에러페이지로 안내해주는데
유저들에게 그런걸 보여주는 것 보다는 따로 에러페이지를 만들어두는게 좋다.

* error.html

Thymeleaf 템플릿 엔진을 build.gradle 파일에 설치해서 쓰는 경우에는 (예) implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  // thymeleaf 외부 라이브러리 설치
그냥 error.html 만들어두면 서버에서 에러가 발생하면 그 웹페이지(error.html)로 자동으로 이동된다.
이게 에러처리끝임

(error.html)

<div>에러페이지임</div>
<p th:text="${status}"></p>
<p th:text="${error}"></p>
<p th:text="${path}"></p>
<p th:text="${message}"></p>
<p th:text="${exception}"></p>

안에 기본적으로 status, error, path 등 에러 원인을 알 수 있는 변수들이 전송되기 때문에
그걸 써서 맘대로 에러페이지를 꾸밀 수 있다.
유저에겐 status, error, path 정도만 알려주는게 좋을 것 같군요. (예) th:text="${status}", th:text="${error}", th:text="${path}"

물론 이거 말고도 다른 상황들이 많이 있을 수 있기 때문에
항상 악성유저처럼 사이트를 이용해보고 그걸 다 막는 코드를 작성해보는 것 부터 시작하면 된다.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
18강 - REST API의 예외처리 방법

타임리프(Thymeleaf) 템플릿 엔진 쓰는경우엔 에러시 자동으로 에러페이지(error.html)로 이동해주기 때문에
이게 에러처리 끝이라고 했다.
근데 웹서버에서 데이터만 보내주는 REST API들을 만드는경우에는
html 에러페이지(error.html)를 보내봤자 아무 의미가 없다.
웹서버와 유저가 데이터만 주고받는 관계라서 html 보내봤자 열지도 못함
그래서 다른 방법이 필요하다.

* try catch

@GetMapping("/detail/{id}")
@ResponseBody
String detail() {
    try {
      에러날 수 있는 코드~~
    } catch(Exception e){
      return "에러남 ㅅㄱ";
    }
}

try catch가 뭐냐면
"try 안에 있는 코드에서 에러가 나면 catch 안에 있는 코드 실행해주세요~" 라는 뜻의 간단한 문법이다.
그래서 에러가 날 수 있는 코드를 try로 감싸고 (에러날 수 있는 코드~~)
에러날 때 실행할 코드(return "에러남 ㅅㄱ";)는 catch 안에 적으면 에러상황에 대처가 가능하다.

예를 들어 DB 입출력하는 코드 실행시 가끔 에러가 날 수 있기 때문에
try로 감싸고 catch 안에는 에러나는 경우에 뭐 유저에게 메세지를 주거나 그러면 되겠군요.

@GetMapping("/detail/{id}")
@ResponseBody
String detail() {
    try {
      throw new Exception("이런저런에러");
    } catch(Exception e){
      System.out.println(e.getMessage());
      return "에러남 ㅅㄱ";
    }
}

- 에러를 강제로 발생시켜보고 싶으면 throw new Exception() 이런 코드 쓰면 강제로 에러발생이 가능하다.
- catch 안에서 e라는 파라미터에 에러이유가 담겨있어서 필요하면 사용가능하다.
진짜 에러시 catch가 동작 잘 하는지 테스트도 해보자.
그래서 웹서버와 유저가 데이터만 주고받는 REST API 만드는 경우엔 에러페이지(error.html)가 안뜨니 이런걸 사용해도 되겠다.

실제 배포후에는 에러시 이거저거 출력보다는 로깅(logging) 라이브러리 쓰는게 낫다.
(나중에 웹서버 배포 후 에러내역 기록해두려면 logging 라이브러리 추천함.)

* throws Exception

@GetMapping("/detail/{id}")
@ResponseBody
String detail() throws Exception {
    throw new Exception("이런저런에러");
}

참고로 함수(detail()) 안에서 에러를 뱉는 코드(throw new Exception("이런저런에러");)가 있는데 try catch를 써서 예외처리를 안했다면
throws Exception이라고 함수뒤에 꼭 써줘야한다. (String detail() throws Exception { ... })
안하면 에디터가가 화냄
근데 별 기능은 없고 여기서 에러뱉을 수 있다는 경고문같은 역할일 뿐이다.
"에러 뱉어서 코드가 정지될 수 있으니 언젠간 try catch를 쓰는게 좋음"이라는 뜻으로 이해하면 되겠다.

* ResponseEntity

@GetMapping("/detail/{id}")
ResponseEntity<String> detail() {  // (참고) ResponseEntity<T>를 쓰는 경우 굳이 @ResponseBody를 붙일 필요 없습니다. 한글 보낼 때 안깨지는 것도 편리함
    try {
      throw new Exception("이런저런에러");
    } catch(Exception e){
      return ResponseEntity.status(에러코드).body("에러이유");
    }
}

REST API에서 에러가 났을 때 문자만 달랑보내기보다는 더 정확하게 에러 코드도 기입해서 보내줄 수 있다. (return ResponseEntity.status(에러코드).body("에러이유");)
위처럼 ResponseEntity라는걸 쓰면 에러코드는 뭔지, 에러이유는 뭔지 맘대로 작성해서 보내줄 수 있다.
(return ResponseEntity.status(에러코드).body("에러이유");)
그럼 프론트엔드에서 웹서버 API 함수에게 요청날릴 때 에러나는 경우 에러 원인이 뭔지 빠르게 파악이 가능하다.

.status() 안에 에러코드를 숫자로 입력하면 되는데
- 유저가 잘못해서 에러나는거면 400
- 서버가 잘못해서 에러나는거면 500
- 에러없이 정상작동하는 경우엔 200
을 관습적으로 넣어준다.
실은 에러났을 때만 .status() 안에 에러코드를 기재하는 건 아니고 그냥 평소에 REST API 만들 때도 .status() 안에 성공코드(200) 기재후에 데이터 보내주면 좋다.

HTTP status code 테이블
참고 URL - https://claude.ai/chat/7852453f-d9b0-4466-a89a-e65df3a40a74
| 200 | Success       | OK                     |
| 201 | Success       | Created                |
| 301 | Redirection   | Moved Permanently      |
| 302 | Redirection   | Found                  |
| 304 | Redirection   | Not Modified           |
| 400 | Client Error  | Bad Request            |
| 401 | Client Error  | Unauthorized           |
| 403 | Client Error  | Forbidden              |
| 404 | Client Error  | Not Found              |
| 500 | Server Error  | Internal Server Error  |
| 501 | Server Error  | Not Implemented        |
| 503 | Server Error  | Service Unavailable    |
| 504 | Server Error  | Gateway Timeout        |

▲ 에러코드라고 했지만 정확히 말하면 HTTP status code인데 이런 것들이 있다.
그래서 상황에 맞는거 찾아서 집어넣으면 되겠다.

ResponseEntity.status(HttpStatus.NOT_FOUND).body("에러남");

HTTP status code 숫자찾기 귀찮으면 에러코드 모아둔 클래스(HttpStatus)가 하나 있는데 거기서 점찍어서 뽑아써도 된다. (예) HttpStatus.NOT_FOUND

예를 들어 데이터나 웹페이지를 못찾는 경우 404를 기입하는게 관습인데
404인지 뭔지 까먹었으면 .NOT_FOUND 찾으면 되는 것이다. (예) HttpStatus.NOT_FOUND
근데 초보가 어찌알겠음 그냥 표 보거나 400, 500, 200 중에 골라쓰면 된다.

(참고) ResponseEntity<T>를 쓰는 경우 굳이 @ResponseBody를 붙일 필요 없다. 한글 보낼 때 안깨지는 것도 편리함

* @ExceptionHandler

try catch 써봤자 try 안에 있는 코드만 에러나는걸 처리할 수 있을 뿐이고
URL 주소 이상하게 입력하거나 그런 에러는 처리하지 못하기 때문에
try catch 쓰는 것 보다는 spring boot가 제공하는 간편한 예외처리 기능하나가 있다.

@ExceptionHandler(Exception.class)
public ResponseEntity<String> exceptionHandler() {
  return ResponseEntity.status().body("");
}

컨트롤러 클래스 (예) ItemController.java 에 속하는 웹서버 API 함수들과 나란하게
@ExceptionHandler 붙은 함수(exceptionHandler())를 컨트롤러 클래스 안에 작성할 수 있는데
이러면 같은 컨트롤러 클래스 안에 있는 웹서버 API 함수 들에서 에러가 나면 @ExceptionHandler 안에 있는 코드를 실행해줍니다.
여기서 return써서 유저에게 메세지보내거나 그러면 된다.
편리하죠?

* @ControllerAdvice

실은 안편리하다.
컨트롤러 클래스 (예) ItemController.java 가 100만개 있으면 직접 그 파일마다 이 코드 넣는게 귀찮아지겠군요.
그래서 한 번에 처리할 수 있는 방법도 있는데

@ControllerAdvice
public class MyExceptionHandler {

  @ExceptionHandler(Exception.class)
  public ResponseEntity<String> handler() {
    return ResponseEntity.status(400).body("모든 컨트롤러 에러시 발동");
  }

}

아무데나 파일하나 만들어보자. 저는 MyExceptionHandler.java 라고 이름지어봤음
@ControllerAdvice를 예외처리 클래스(MyExceptionHandler) 상단에 붙이고
해당 예외처리 클래스(MyExceptionHandler) 안에 아까 그 @ExceptionHandler를 넣는것이다.
이러면 웹 프로젝트 폴더 (예) shop 안에 속한 모든 컨트롤러 클래스 (예) ItemController.java 등등... 에서 에러가 나는 경우
여기 있는 코드(public ResponseEntity<String> handler() { ... })가 대신 실행된다.
진짜 그런가 실험해보자.

참고로 개별 컨트롤러 (예) ItemController.java 에도 @ExceptionHandler를 만들어놨고
@ControllerAdvice 붙인 예외처리 클래스(MyExceptionHandler)에도 @ExceptionHandler를 만들어놨으면
당연히 개별 컨트롤러 (예) ItemController.java 에 있는 @ExceptionHandler 코드가 더 우선권이 있다. (함수내 지역변수 우선 적용과 비슷함.)

* 특정에러에만 실행하기

@ControllerAdvice
public class MyExceptionHandler {

  @ExceptionHandler(MethodArgumentTypeMismatchException.class)
  public ResponseEntity<String> handler() {
    return ResponseEntity.status(400).body("특정 에러시 발동");
  }

}

MethodArgumentTypeMismatchException.class 이런 이름의 에러가 발생시에는 다른 코드를 실행하고 싶다면
위처럼 에러 이름을 @ExceptionHandler() 안에 적으면 된다. (예) @ExceptionHandler(MethodArgumentTypeMismatchException.class)
예를 들어 URL에 숫자말고 문자를 입력하면 저런 이름의 에러가 뜨는데
에러 이름은 실행창(콘솔창)에서 베껴와봤다.


오늘의 결론 :
웹서버만들 때는 예외상황과 에러상황에 대처하는 코드를 안적으면 행복했던 코딩 인생이 금방 끝난다.
악성 유저가 되어서 이거저거 상황을 만들어보고 그걸 대처하는 코드를 작성하자.
Thymeleaf 템플릿 엔진 사용시엔 에러나는거 처리는 에러페이지(error.html) 만들면 끝인데
웹서버와 유저가 데이터만 주고받는 REST API 만들 때는 에러나는거 처리는 @ControllerAdvice 만들어놓는게 편리함

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
19강 - Service 레이어로 분리하려면

근데 함수 만들 때 지키면 좋은 원칙같은게 있는데
하나의 함수 안에는 하나의 기능만 담는게 좋다.
그래야 나중에 관리가 편해질 수 있다.

@PostMapping("/add")
String writePost(String title, Integer price) {
  Item item = new Item();
  item.setTitle(title);
  item.setPrice(price);
  itemRepository.save(item);
  return "redirect:/list";
}

▲ 지금 API 만들어둔 것도 일종의 함수인데 (웹서버 API 함수)
1. DB에 데이터 입출력하는 기능
2. html을 보내주는 기능
이렇게 2개 기능이 있는데 하나는 다른 함수로 빼는 게 좋다.
왜냐면 소스 정리를 잘 해둬야 나중에 찾기도 쉽고 기능변경도 쉬워져서 그렇다. (유지보수 용이함.)

근데 2번은 Controller 본연의 역할(기능)에 어울리기 때문에
1번을 다른 곳으로 빼보도록 하자.
다른 클래스에 함수하나 만들어서 DB입출력하는 4줄의 코드를 거기로 옮겨보자.

Q. 왜 굳이 다른 클래스를 만들죠?
- 하나의 클래스에도 비슷한 기능의 함수들만 보관하는게 나중에 찾기 쉬움 (유지보수 용이함.)

* Service 클래스로 코드 옮기기

public class ItemService {

  public void saveItem(){
    Item item = new Item();
    item.setTitle(title);
    item.setPrice(price);
    itemRepository.save(item);
  }

}

그래서 위처럼 ItemService라는 클래스 하나 만들고 그 안에 함수(saveItem) 하나 만들어서 그 4줄의 코드를 옮겨적어봤다.

Q. 왜 ItemService라고 작명함?
- 원래 웹서버가 유저에게 데이터 전송 전에 이거저거 검사하거나 DB 데이터 입출력 처리해주는 비즈니스 로직 클래스 같은걸 Service라고 보통 부른다.

@RequiredArgsConstructor - Lombok 문법
public class ItemService {
  private final ItemRepository itemRepository;

  public void saveItem(String title, Integer price){
    Item item = new Item();
    item.setTitle(title);
    item.setPrice(price);
    itemRepository.save(item);
  }
}

다른 함수로 코드를 분리할 때 주의점이 있는데
ItemService 클래스의 함수 안에 정의되지 않은 변수(예 - title, price)들을 정의해줘야 한다.
해결법은 쉬운데 그냥 전부 함수 파라미터로 입력할 수 있게 만들면 된다. (예 - saveItem(String title, Integer price))
이제 앞으로 saveItem() 쓸 때 title, price 변수를 파라미터로 입력해서 쓰면 될 것 같군요. (예 - saveItem(String title, Integer price))

근데 itemRepository 변수(private final ItemRepository itemRepository;)도 ItemService 클래스에 정의가 안되었다는데요?
그것도 파라미터로 입력할 수 있게 만들어도 되긴 하는데
근데 DB입출력함수 쓰려면 3-step 그게 있지 않습니까 그거 해도 됩니다.
아무튼 그럼 웹서버 API 함수 안에서 new ItemService().saveItem() 이런걸 사용하면 되겠군요.

참고 - 테이블에서 데이터 입출력하려면 항상 3-step 이 필요하다.
1. repository라는걸 만들고 (예) interface ItemRepository.java
2. DB입출력 원하는 클래스에서 repository를 등록하고 (예) private final ItemRepository itemRepository;
3. DB입출력문법 가져다가 쓰면 된다. (예) itemRepository.save(item);

* 다른 클래스의 함수 사용하려면

근데 new ItemService().saveItem() 해서 사용하면 뭔가 비효율적인 것 같지 않습니까
왜냐면 /add로 요청이 들어올 때 마다 매번 new 키워드로 object를 뽑아야하니까요.
그게 싫으면 그냥 object를 한 번 뽑고 그걸 변수에 저장해뒀다가 계속 재사용하는 식으로 코드짜도 된다. (싱글톤 패턴 방식)
근데 그걸 여러분이 직접 (싱글톤 패턴 방식) 코드로 구현해도 되겠지만 스프링에게 시킬 수도 있다.

3-step이 필요한데

1. 클래스에 @Service 붙여놓고
(예)
@Service
@RequiredArgsConstructor - Lombok 문법
public class ItemService {
  private final ItemRepository itemRepository;

  public void saveItem(String title, Integer price){
    Item item = new Item();
    item.setTitle(title);
    item.setPrice(price);
    itemRepository.save(item);
  }
}

2. 이 함수들 쓰고싶은 곳에 가서 변수로 등록하고 (@RequiredArgsConstructor 필요) (예) ItemController.java -> ItemController 클래스 -> private final ItemService itemService;
3. 원하는 곳에서 변수.함수() 쓰면 된다. (예) ItemController.java -> ItemController 클래스 -> 웹서버 API 함수 writePost -> itemService.saveItem(title, price);

@Service
@RequiredArgsConstructor - Lombok 문법
public class ItemService {

}
1. 위처럼 함수가 담긴 클래스(ItemService)에 @Service 붙여놓고

@Controller
@RequiredArgsConstructor - Lombok 문법
public class ItemController {
  private final ItemRepository itemRepository;
  private final ItemService itemService;

  @PostMapping("/add")
  String writePost(String title, Integer price) {
    itemService.saveItem(title, price);
    return "redirect:/list";
  }

}

2. 위처럼 이 함수들 쓰고싶은 곳에 가서 변수(itemService)로 등록하고 (@RequiredArgsConstructor 필요) (예) ItemController.java -> ItemController 클래스 -> private final ItemService itemService;
3. 원하는 곳(웹서버 API 함수 - writePost)에서 변수.함수(itemService.saveItem(title, price);) 쓰면 된다. (예) ItemController.java -> ItemController 클래스 -> 웹서버 API 함수 writePost -> itemService.saveItem(title, price);

참고로 @Service 말고 @Service, @Repository, @Component 이런거 붙여놔도 기능이 똑같다.
아무튼 상품추가기능 똑같이 잘되는지 한번 테스트해보십쇼

* dependency injection 설명시간

지금 Lombok 문법 덕분에 코드를 길게 안짜도 되는데
Lombok을 안쓰면 이렇게 더럽게 코드를 짜야한다.

@Controller
//@RequiredArgsConstructor
public class ItemController {
  private final ItemRepository itemRepository;
  private final ItemService itemService;

  @Autowired
  ItemController(ItemRepository itemRepository, ItemService itemService) {
   this.itemRepository = itemRepository;
   this.itemService = itemService;
  }

}

위 문법을 쉽게 말하면
"스프링(Spring)아 니가 알아서 new ItemService()를 ItemController 생성자의 파라미터인 itemService 변수에 넣어둬라" 이다.

어렵게 멋있게 말하면
내부적으로 ItemController 생성자인 이것도 나중에 new ItemController() 이런 식으로 사용될텐데
그 때 new ItemService()도 new ItemController(new ItemService()) 이렇게 집어넣어서
ItemController 생성자의 파라미터인 itemService 변수에 넣어달라는 소리이다.
ItemController 생성자의 또 다른 파라미터인 itemRepository도 마찬가지이다.

(참고) ItemController 생성자 위에 붙인 @Autowired는 ItemRepository, ItemService 클래스 이름의 타입만 붙여둔 자리에
new ItemRepository(), new ItemService() 알아서 찾아와서
ItemController 생성자의 파라미터인 itemRepository, itemService 변수에 넣으라는 스프링 문법이다.

이런 식으로 코드짜는 패턴을 멋있는 개발자말로 dependency injection이라고 한다.
다른 클래스의 변수, 함수를 사용할 때
new 클래스().함수() 이렇게 매번 쓰는게 아니라
new 클래스()를 다른데서 미리 뽑아놓은 다음에
그것만 클래스 생성자의 파라미터로 작성된 변수에 집어넣어서 해당 변수를 쓰게 만드는걸 dependency injection이라고 부름

* dependency injection 쓰는 이유

개짓거리를 배우고 나면 이 개짓거리는 왜 하는지 생각해보라고 했다.
그래야 나중에 마음대로 활용을 할 것 아닙니까

장점1. 매번 object를 뽑아쓰지 않아도 되니까 성능상 효율적임
이러면 웹서버 API 함수가 실행될 때 마다 object를 새로 뽑을 필요가 없다.
object를 하나만 뽑아놓고 프로그램이 실행 중인 상태에서 계속 재사용하는걸 싱글톤 패턴이라고 부르기도 한다.

장점2. 클래스간의 연결고리를 줄일 수 있다.
클래스간의 커플링을 줄여서 클래스들을 서로 독립적으로 깔끔하게 유지할 수 있어서 쓰는 이유도 있다.
클래스1에서 new 클래스2(); 하면 클래스간에 커플링(연결고리)이 생긴다고 한다.

(예)
public class 클래스1 {
  클래스1() {
    new 클래스2();
  }
}

이러면 나중에 클래스2가 변경되면 그걸 쓰는 클래스1도 찾아가서 변경해야하지 않겠습니까
그래서 커플링을 줄이면 유지보수 및 관리가 편해질 수 있다.

* Container, Bean이라는 용어

-----------------------------------
| Spring IoC Container            |
|                                 |
| new ItemService() <- Bean       |
| new ItemRepository() <- Bean    |
-----------------------------------

멋있어보이는 용어 하나만 더 배우고 지나가자.
스프링(Spring)이 몰래 object를 하나 뽑아서 알아서 생성자 파라미터 변수에 집어넣어준다고 했는데
근데 스프링(Spring)이 object를 뽑아서 보관하는 공간 같은게 있을 것 아닙니까
그걸 Container 아니면 IOC Container라고 부른다.
거기 안에 들어있는 object들을 Spring의 Bean(객체 의미함)이라고 부른다.

참고로 @Service, @Component 이런걸 클래스에 붙여놓으면
(예)
@Service
@Component
public class Test {
  // ...
}
"웹서버가 실행될 때 @Service, @Component 붙은 클래스(예 - Test)의 object를 뽑아서(예 - new Test()) Spring IoC Container 안에 담아놓으라"는 뜻이다.
그리고 그 때 스프링(Spring)이 뽑아준 object가 Spring의 Bean(객체 의미함)이다.

* Service layer 예외처리 방법

Service 클래스에 있는 코드들도 예외상황이 발생할 수 있다.
예를들어 가격을 DB에 저장해주고 있는데 가격이 음수로 들어오면 어쩌죠?

if문으로 검사해보고 가격이 음수면 다른 웹페이지로 이동시키거나 그러면 될 것 같은데
근데 Service 클래스에서 다른 웹페이지로 이동시키거나 그런 코드는 보통 넣지 않는다.
가능은 한데 웹페이지 이동은 Controller에 있는 코드가 담당하는게 더 어울린다.

그래서 예외처리는 크게 2개 방법이 있는데
1. 예외상황 발생시 Serivce 클래스에 있는 함수에서 실패했다고 메세지 같은걸 return 하기
- 이럴 경우 Service함수() 호출해서 사용하는 다른 클래스에서 1번의 return 결과에 따라서 if 문을 또 써야하기 때문에 귀찮고
함수들 간에 연결고리(커플링)가 생겨버리고 로직도 복잡해져서 귀찮아짐

2. 예외상황 발생시 에러를 발생시키기
- 그렇게 해두면 타임리프(Thymeleaf) 템플릿 엔진 쓰는 경우 에러페이지(error.html)로 자동 이동하고
웹서버와 유저가 데이터만 주고받는 REST API의 경우엔 자동으로 @ExceptionHandler 만들어놓은게 동작한다.
이게 가장 깔끔하다.

(Service 함수)
public void saveItem(String title, Integer price){
    if (price < 0) {
      throw new RuntimeException("음수 안됩니다");
    }
    (실행할 코드~~)
}

이런 식으로 if를 쓰거나 try, catch를 쓰거나 해서 이상한 상황에는 강제로 에러를 발생시키면 됩니다.
참고로 Exception()은 문법상 꼭 try, catch를 강제로 사용해야 하기 때문에 귀찮아서
일부러 에러 발생시킬 땐 RuntimeException() 이런걸 더 주로 많이 사용한다.
그렇게 예외처리(try, catch) 사용 안해도 눈감아주는 Exception들을 unchecked Exception(RuntimeException())이라고 부른다.

* Exception은 여러가지 준비되어있음

RuntimeException 보다 더 정확한걸 쓰는게 좋은데
들어온 값이 더러우면 MethodArgumentNotValidException, IllegalArgumentException
URL이 이상하면 MissingServletRequestParameterException, NoHandlerFoundException
등 여러가지가 있어서 때에 맞춰 쓰는게 좋다.
외우기 귀찮으면 AI에게 물어보는게 빠르다.

throw new ResponseStatusException(
       HttpStatus.NOT_FOUND, "어쩌구 때문에 404에러남"
);

아니면 에러를 발생시킬 때 더 정확하게 에러코드(HttpStatus.NOT_FOUND)도 적고 싶으면
ResponseStatusException() 이런 것도 사용가능하다.
참고로 에러메세지 같은 경우 매우 상세하게 적으면 해킹시 많은 도움이 되니 적당히 적는게 좋다.

오늘의 결론 :
1. 데이터 또는 html 파일 보내주는 Controller 기능 말고 다른 기능은 Service 클래스로 빼는게 좋을 수 있다.
2. 다른 클래스에 있던 함수를 효율적으로 쓰고 싶으면 3-step을 잘 기억해두자.

(예)
1) 클래스에 @Service 붙여놓고
(예)
@Service
@RequiredArgsConstructor - Lombok 문법
public class ItemService {
  private final ItemRepository itemRepository;

  public void saveItem(String title, Integer price){
    Item item = new Item();
    item.setTitle(title);
    item.setPrice(price);
    itemRepository.save(item);
  }
}

2) 이 함수들 쓰고싶은 곳에 가서 변수로 등록하고 (@RequiredArgsConstructor 필요) (예) ItemController.java -> ItemController 클래스 -> private final ItemService itemService;
3) 원하는 곳에서 변수.함수() 쓰면 된다. (예) ItemController.java -> ItemController 클래스 -> 웹서버 API 함수 writePost -> itemService.saveItem(title, price);

3. dependency injection을 쓰는 이유 배움

오늘의 숙제 :
1. 심심하니까 다른 Controller 함수들에 있던 코드도
html 보내주는 기능과 관련이 없다면 서비스 레이어(Service layer)로 코드를 옮겨서 사용해보자.
2. 상품명이 너무 긴 경우엔 어떻게 할지 예외처리를 해보고 잘 되나 테스트까지 해보자.
3. 가격이 음수거나 너무 큰 경우도 예외처리를 해주자.
강의만 쭉 들어봤자 실력 하나도 안늘으니 직접 해보도록 하자.

[코딩애플] 쉽게 배우는 Spring Boot & JPA
Part 2
20강 - 수정기능 1

상품정보를 수정하는 기능을 만들어보자.
수정기능 만드는걸 저한테 배워야 만들 수 있는게 아니라
수정기능이 어떻게 동작하는지 한글로 자세히 설명부터 하고
그거 그대로 코드로 번역만 하면 되니 강의 끄고 알아서 해오도록 하자.

- 한글로 설명을 못하겠으면 다른 사이트 벤치마크해보고
- 특정 부분을 코드로 번역 하는 법을 모르면 찾아보면 되고
- 어려우면 한 번에 글 4개 수정기능 한 번에 다 만들려고 하지말고
글 하나만 찝어서 그거 수정하는 기능부터 만들어보십쇼.

* 수정기능을 글로 설명부터 해보면

삶과 공부의 의지가 없는 분들은 저랑 같이 해보자.
이것도 일종의 게시판이기 때문에 게시판 글수정 기능이 어떻게 동작하는지 설명부터 해보자면
1. 글마다 수정버튼이 있는데 누르면 글수정 웹페이지(edit.html)로 이동
2. 그 웹페이지엔 폼(<form>)이 있고 글의 내용이 이미 채워져있음
3. 전송누르면 그걸로 DB의 기존 글 수정

* 1. 버튼누르면 수정페이지로 이동

버튼누르면 특정 웹페이지로 이동시키고 싶으면 <a href="/url"> 쓰면 된다.

(list.html)

<div class="card" th:each="i : ${items}">
    <img src="https://placehold.co/300">
    (생략)
    <a th:href="/???">✏️</a>
</div>

글목록 웹페이지(list.html)에 a태그(<a th:href="/???">✏️</a>) 하나 만들어봤고
해당 a태그(<a th:href="/???">✏️</a>) 누르면 글수정 웹페이지(edit.html)로 이동하게 하자.
근데 글수정 웹페이지(edit.html) URL은 안 만들었으니 웹서버 컨트롤러(ItemController.java)에서 하나 만들어보자.

(ItemController.java)

@GetMapping("/edit")
String edit() {
  return "edit.html";
}

웹서버 컨트롤러(ItemController.java)에서 글수정 웹페이지(edit.html) 보내줄 웹서버 API 함수(edit()) 하나 만들었다.

(edit.html)

<form action="/???" method="POST">
  <input name="title">
  <input name="price">
  <button type="submit">전송</button>
</form>

글수정 웹페이지(edit.html) html 파일도 만들었다.
html 내용(코드)은 글작성 웹페이지(write.html)랑 똑같을거같아서 그대로 복사해옴

Q. 근데 글이 4개라 글수정 웹페이지(edit.html)도 4개 필요하지 않음?
- 맞습니다

/edit/1로 접속하면 1번글 내용이 채워진 글수정 웹페이지(edit.html)
/edit/2로 접속하면 2번글 내용이 채워진 글수정 웹페이지(edit.html)
...
이렇게 만들면 될 것 같은데
웹서버 API 함수 비슷한거 여러개 만드는 뻘짓 싫으면 뭐하라고했습니까
URL 파라미터 문법 사용하면 된다.

(ItemController.java)

@GetMapping("/edit/{id}")
String edit() {
  return "edit.html";
}

이러면 누가 /edit/1 로 접속하든 /edit/2로 접속하든 글수정 웹페이지(edit.html)를 잘 보여줄 수 있겠군요.

갑자기 이런거 쓰면 복잡해서 어렵다고요?
그럼 빡대가리 모드로 코딩해보도록 하자.
한 번에 4개의 웹페이지와 기능을 전부 만들려고 하지 말고 1개의 기능만 먼저 만든다. 그 다음 확장하면 된다.
1번 글의 글수정 웹페이지(edit.html)와 기능만 만들어보는 빡대가리 모드로 가보자.

* 2. 그 페이지엔 폼이 있고 글 내용이 이미 채워져있음

/edit/1로 접속하면 id가 1번 글의 내용이 채워져있어야한다.
근데 접속해보면 지금은 빈칸이군요.
그럼 DB에서 id가 1번 글 가져와서 여기다가 박아주면 되는 것 아닙니까

(ItemController.java)

@GetMapping("/edit/{id}")
String edit(Model model) {
  Optional<Item> result = itemRepository.findById(1L);
  if (result.isPresent()) {
    model.addAttribute("data", result.get());
    return "edit.html";
  } else {
    return "redirect:/list";
  }
}

그래서 id가 1인 글을 DB에서 가져와서 html에 넣으라고 했다.(model.addAttribute("data", result.get());)

(edit.html)

<form action="/???" method="POST">
  <input name="title" th:value="${data.title}">
  <input name="price" th:value="${data.price}">
  <button type="submit">전송</button>
</form>

그걸 html에 박아봤다. (th:value="${data.title}" / th:value="${data.price}")
value속성(th:value) 만지면 이미 채워진 값("${data.title}" / "${data.price}")을 맘대로 설정할 수 있다.
나머지 3. 전송누르면 그걸로 DB를 수정하는건 알아서 해오자.

오늘의 숙제 :
수정기능을 알아서 완성해오자.

힌트1. DB내용 수정은 .save() 쓰면 된다.
.save() 안에 object 하나 넣으면 그 내용으로 행을 하나 추가해준다고 했는데
예외가 있다.
추가하려는 id가 이미 테이블에 존재하면 추가가 아니라 기존 내용을 덮어쓰기 해준다. (update 처리 해줌.)
그게 수정(update)임

힌트2. 서버에서 어떤 정보가 필요한데 정보가 없다면
유저에게 보내라고하거나 DB에서 뽑아보거나 택1 하면 되겠다.




























































































































